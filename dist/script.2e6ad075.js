parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"jSD1":[function(require,module,exports) {
module.exports=function(o){return o&&"object"==typeof o&&"function"==typeof o.copy&&"function"==typeof o.fill&&"function"==typeof o.readUInt8};
},{}],"F8IV":[function(require,module,exports) {
"function"==typeof Object.create?module.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(t,e){t.super_=e;var o=function(){};o.prototype=e.prototype,t.prototype=new o,t.prototype.constructor=t};
},{}],"g5IB":[function(require,module,exports) {

var t,e,n=module.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(e){if(t===setTimeout)return setTimeout(e,0);if((t===r||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}function u(t){if(e===clearTimeout)return clearTimeout(t);if((e===o||!e)&&clearTimeout)return e=clearTimeout,clearTimeout(t);try{return e(t)}catch(n){try{return e.call(null,t)}catch(n){return e.call(this,t)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:r}catch(n){t=r}try{e="function"==typeof clearTimeout?clearTimeout:o}catch(n){e=o}}();var c,s=[],l=!1,a=-1;function f(){l&&c&&(l=!1,c.length?s=c.concat(s):a=-1,s.length&&h())}function h(){if(!l){var t=i(f);l=!0;for(var e=s.length;e;){for(c=s,s=[];++a<e;)c&&c[a].run();a=-1,e=s.length}c=null,l=!1,u(t)}}function m(t,e){this.fun=t,this.array=e}function p(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new m(t,e)),1!==s.length||l||i(h)},m.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0};
},{}],"wqTM":[function(require,module,exports) {
var process = require("process");
var e=require("process"),t=Object.getOwnPropertyDescriptors||function(e){for(var t=Object.keys(e),r={},n=0;n<t.length;n++)r[t[n]]=Object.getOwnPropertyDescriptor(e,t[n]);return r},r=/%[sdj%]/g;exports.format=function(e){if(!v(e)){for(var t=[],n=0;n<arguments.length;n++)t.push(i(arguments[n]));return t.join(" ")}n=1;for(var o=arguments,u=o.length,s=String(e).replace(r,function(e){if("%%"===e)return"%";if(n>=u)return e;switch(e){case"%s":return String(o[n++]);case"%d":return Number(o[n++]);case"%j":try{return JSON.stringify(o[n++])}catch(t){return"[Circular]"}default:return e}}),c=o[n];n<u;c=o[++n])h(c)||!S(c)?s+=" "+c:s+=" "+i(c);return s},exports.deprecate=function(t,r){if(void 0!==e&&!0===e.noDeprecation)return t;if(void 0===e)return function(){return exports.deprecate(t,r).apply(this,arguments)};var n=!1;return function(){if(!n){if(e.throwDeprecation)throw new Error(r);e.traceDeprecation?console.trace(r):console.error(r),n=!0}return t.apply(this,arguments)}};var n,o={};function i(e,t){var r={seen:[],stylize:s};return arguments.length>=3&&(r.depth=arguments[2]),arguments.length>=4&&(r.colors=arguments[3]),b(t)?r.showHidden=t:t&&exports._extend(r,t),j(r.showHidden)&&(r.showHidden=!1),j(r.depth)&&(r.depth=2),j(r.colors)&&(r.colors=!1),j(r.customInspect)&&(r.customInspect=!0),r.colors&&(r.stylize=u),p(r,e,r.depth)}function u(e,t){var r=i.styles[t];return r?"["+i.colors[r][0]+"m"+e+"["+i.colors[r][1]+"m":e}function s(e,t){return e}function c(e){var t={};return e.forEach(function(e,r){t[e]=!0}),t}function p(e,t,r){if(e.customInspect&&t&&P(t.inspect)&&t.inspect!==exports.inspect&&(!t.constructor||t.constructor.prototype!==t)){var n=t.inspect(r,e);return v(n)||(n=p(e,n,r)),n}var o=l(e,t);if(o)return o;var i=Object.keys(t),u=c(i);if(e.showHidden&&(i=Object.getOwnPropertyNames(t)),E(t)&&(i.indexOf("message")>=0||i.indexOf("description")>=0))return f(t);if(0===i.length){if(P(t)){var s=t.name?": "+t.name:"";return e.stylize("[Function"+s+"]","special")}if(w(t))return e.stylize(RegExp.prototype.toString.call(t),"regexp");if(z(t))return e.stylize(Date.prototype.toString.call(t),"date");if(E(t))return f(t)}var b,h="",m=!1,x=["{","}"];(d(t)&&(m=!0,x=["[","]"]),P(t))&&(h=" [Function"+(t.name?": "+t.name:"")+"]");return w(t)&&(h=" "+RegExp.prototype.toString.call(t)),z(t)&&(h=" "+Date.prototype.toUTCString.call(t)),E(t)&&(h=" "+f(t)),0!==i.length||m&&0!=t.length?r<0?w(t)?e.stylize(RegExp.prototype.toString.call(t),"regexp"):e.stylize("[Object]","special"):(e.seen.push(t),b=m?a(e,t,r,u,i):i.map(function(n){return y(e,t,r,u,n,m)}),e.seen.pop(),g(b,h,x)):x[0]+h+x[1]}function l(e,t){if(j(t))return e.stylize("undefined","undefined");if(v(t)){var r="'"+JSON.stringify(t).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(r,"string")}return x(t)?e.stylize(""+t,"number"):b(t)?e.stylize(""+t,"boolean"):h(t)?e.stylize("null","null"):void 0}function f(e){return"["+Error.prototype.toString.call(e)+"]"}function a(e,t,r,n,o){for(var i=[],u=0,s=t.length;u<s;++u)A(t,String(u))?i.push(y(e,t,r,n,String(u),!0)):i.push("");return o.forEach(function(o){o.match(/^\d+$/)||i.push(y(e,t,r,n,o,!0))}),i}function y(e,t,r,n,o,i){var u,s,c;if((c=Object.getOwnPropertyDescriptor(t,o)||{value:t[o]}).get?s=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(s=e.stylize("[Setter]","special")),A(n,o)||(u="["+o+"]"),s||(e.seen.indexOf(c.value)<0?(s=h(r)?p(e,c.value,null):p(e,c.value,r-1)).indexOf("\n")>-1&&(s=i?s.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+s.split("\n").map(function(e){return"   "+e}).join("\n")):s=e.stylize("[Circular]","special")),j(u)){if(i&&o.match(/^\d+$/))return s;(u=JSON.stringify(""+o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(u=u.substr(1,u.length-2),u=e.stylize(u,"name")):(u=u.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),u=e.stylize(u,"string"))}return u+": "+s}function g(e,t,r){return e.reduce(function(e,t){return 0,t.indexOf("\n")>=0&&0,e+t.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?r[0]+(""===t?"":t+"\n ")+" "+e.join(",\n  ")+" "+r[1]:r[0]+t+" "+e.join(", ")+" "+r[1]}function d(e){return Array.isArray(e)}function b(e){return"boolean"==typeof e}function h(e){return null===e}function m(e){return null==e}function x(e){return"number"==typeof e}function v(e){return"string"==typeof e}function O(e){return"symbol"==typeof e}function j(e){return void 0===e}function w(e){return S(e)&&"[object RegExp]"===T(e)}function S(e){return"object"==typeof e&&null!==e}function z(e){return S(e)&&"[object Date]"===T(e)}function E(e){return S(e)&&("[object Error]"===T(e)||e instanceof Error)}function P(e){return"function"==typeof e}function D(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e}function T(e){return Object.prototype.toString.call(e)}function N(e){return e<10?"0"+e.toString(10):e.toString(10)}exports.debuglog=function(t){if(j(n)&&(n=""),t=t.toUpperCase(),!o[t])if(new RegExp("\\b"+t+"\\b","i").test(n)){var r=e.pid;o[t]=function(){var e=exports.format.apply(exports,arguments);console.error("%s %d: %s",t,r,e)}}else o[t]=function(){};return o[t]},exports.inspect=i,i.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},i.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=d,exports.isBoolean=b,exports.isNull=h,exports.isNullOrUndefined=m,exports.isNumber=x,exports.isString=v,exports.isSymbol=O,exports.isUndefined=j,exports.isRegExp=w,exports.isObject=S,exports.isDate=z,exports.isError=E,exports.isFunction=P,exports.isPrimitive=D,exports.isBuffer=require("./support/isBuffer");var F=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function k(){var e=new Date,t=[N(e.getHours()),N(e.getMinutes()),N(e.getSeconds())].join(":");return[e.getDate(),F[e.getMonth()],t].join(" ")}function A(e,t){return Object.prototype.hasOwnProperty.call(e,t)}exports.log=function(){console.log("%s - %s",k(),exports.format.apply(exports,arguments))},exports.inherits=require("inherits"),exports._extend=function(e,t){if(!t||!S(t))return e;for(var r=Object.keys(t),n=r.length;n--;)e[r[n]]=t[r[n]];return e};var J="undefined"!=typeof Symbol?Symbol("util.promisify.custom"):void 0;function R(e,t){if(!e){var r=new Error("Promise was rejected with a falsy value");r.reason=e,e=r}return t(e)}function H(r){if("function"!=typeof r)throw new TypeError('The "original" argument must be of type Function');function n(){for(var t=[],n=0;n<arguments.length;n++)t.push(arguments[n]);var o=t.pop();if("function"!=typeof o)throw new TypeError("The last argument must be of type Function");var i=this,u=function(){return o.apply(i,arguments)};r.apply(this,t).then(function(t){e.nextTick(u,null,t)},function(t){e.nextTick(R,t,u)})}return Object.setPrototypeOf(n,Object.getPrototypeOf(r)),Object.defineProperties(n,t(r)),n}exports.promisify=function(e){if("function"!=typeof e)throw new TypeError('The "original" argument must be of type Function');if(J&&e[J]){var r;if("function"!=typeof(r=e[J]))throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(r,J,{value:r,enumerable:!1,writable:!1,configurable:!0}),r}function r(){for(var t,r,n=new Promise(function(e,n){t=e,r=n}),o=[],i=0;i<arguments.length;i++)o.push(arguments[i]);o.push(function(e,n){e?r(e):t(n)});try{e.apply(this,o)}catch(u){r(u)}return n}return Object.setPrototypeOf(r,Object.getPrototypeOf(e)),J&&Object.defineProperty(r,J,{value:r,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(r,t(e))},exports.promisify.custom=J,exports.callbackify=H;
},{"./support/isBuffer":"jSD1","inherits":"F8IV","process":"g5IB"}],"ommy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UnrecognizedTokenException=exports.RuleSetter=exports.RuleApplier=exports.Reducer=exports.ProofChecker=exports.Parser=exports.Lexer=exports.InvalidProofSequenceException=exports.InvalidFormulaException=exports.InferenceException=exports.Frege=exports.Calculator=exports.Builder=void 0,exports.biconditional=M,exports.buildConjunctionString=D,exports.conjunction=q,exports.disjunction=A,exports.eliminateDoubleNegations=f,exports.frege=void 0,exports.haveEvenNumberOfNegations=j,exports.implication=S,exports.inferenceRulesMap=void 0,exports.isArrayString=g,exports.isBiconditional=c,exports.isBinaryOperationFormula=a,exports.isConjunction=u,exports.isContradiction=d,exports.isDisjunction=l,exports.isEndOfHypothesis=I,exports.isHypothesis=w,exports.isImplication=h,exports.isMolecularFormula=m,exports.isNegation=p,exports.isProofItemInferred=x,exports.isPropositionalVariable=y,exports.negation=T,exports.parseToFormulaObject=C,exports.parseToFormulaString=N,exports.printTruthTable=L;var t=require("util"),o=class extends Error{};exports.InvalidFormulaException=o;var i=class extends Error{};exports.InferenceException=i;var n=class extends Error{};exports.InvalidProofSequenceException=n;var e=class extends Error{};exports.UnrecognizedTokenException=e;var r=class{static biconditional(t,o){return`(${t} <-> ${o})`}static conjunction(t,o){return`(${t} âˆ§ ${o})`}static disjunction(t,o){return`(${t} âˆ¨ ${o})`}static implication(t,o){return`(${t} -> ${o})`}static buildRecursively(t){if("string"==typeof t)return t;if("operation"in t&&"Negation"===t.operation)return`Â¬(${this.buildFormula(t.value)})`;if(!("operation"in t))throw new o("Invalid Formula.");const i=this.buildFormula(t.left),n=this.buildFormula(t.right),e=t.operation;return this.operations[e](i,n)}static buildFormula(t){return this.buildRecursively(t)}};r.operations={Biconditional:r.biconditional,Conjunction:r.conjunction,Disjunction:r.disjunction,Implication:r.implication};var s=exports.Builder=r;function a(t){return!!(t.operation&&t.left&&t.right)}function c(t){return"Biconditional"===t.operation&&a(t)}function u(t){return"Conjunction"===t.operation&&a(t)}function l(t){return"Disjunction"===t.operation&&a(t)}function h(t){return"Implication"===t.operation&&a(t)}function p(t){return"Negation"===t.operation&&!!t.value}function f(t){if(p(t)){const o=t.value;return p(o)?f(o.value):{operation:"Negation",value:f(o)}}return a(t)?{operation:t.operation,left:f(t.left),right:f(t.right)}:t}function d(o){o=f(o);const i=(0,t.isDeepStrictEqual)(o,{operation:"Conjunction",left:o.left,right:{operation:"Negation",value:o.left}}),n=(0,t.isDeepStrictEqual)(o,{operation:"Conjunction",left:{operation:"Negation",value:o.right},right:o.right});return i||n}function g(t){return t.every(t=>"string"==typeof t)}function w(t){return"Hypothesis"===t.type}function I(t){return"End of Hypothesis"===t.type}function m(t){return"string"!=typeof t&&"Negation"!==t.operation}function x(t){return!(null==t||!t.type)&&["Knowledge","End of Hypothesis","Conclusion"].includes(t.type)}var v=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];function y(t){return"string"==typeof t&&v.includes(t)}function D(t){return t.map(t=>`(${t})`).join("âˆ§")}function j(t){return!p(t)||!p(t=f(t))}var E=class{constructor(t){this.tokens=[],this.pointer=0,this.operator="",this.input=t}lex(){for(;this.next();)if(this.isSpecial(this.c))this.operator+=this.c,this.operatorExists(this.operator)&&(this.push({type:"operator",value:this.operator}),this.operator="");else if(this.operator)this.throwTokenException(this.operator,this.pointer-this.operator.length-1);else{if(this.isWhiteSpace(this.c))continue;this.isVariable(this.c)?this.push({type:"variable",value:this.c}):this.isExpressionBoundary(this.c)?this.push({type:"boundary",value:this.c}):this.throwTokenException(this.c,this.pointer-2)}return this.tokens}next(){return this.c=this.input[this.pointer++]}push(t){this.tokens.push({type:t.type,value:t.value})}isWhiteSpace(t){return/\s/.test(t)}isVariable(t){return/[A-Z]/.test(t)}isSpecial(t){return/[Â¬âˆ§âˆ¨&!|\-><->]/.test(t)}isExpressionBoundary(t){return/[\(\)]/.test(t)}operatorExists(t){return-1!==["Â¬","!","âˆ§","&","âˆ¨","|","->","<->"].indexOf(t)}throwTokenException(t,o){throw new e(`Unrecognized token "${t}" on position ${o}`)}};exports.Lexer=E;var b=class extends Error{},$=class{constructor(t){this.lastIsVariable=!1,this.tokens=JSON.parse(JSON.stringify(t))}parse(){return this.process()}process(t){var o,i,n,e,r,s;t=t||null;const a=[];for(;this.next();){if(this.lastIsVariable&&"variable"===(null==(o=this.token)?void 0:o.type))throw new b(`Token "${this.token.value}": Expected one variable, but received more than 1.`);if(void 0===this.token)break;if("boundary"===(null==(i=this.token)?void 0:i.type)){if(")"===this.token.value)return this.node(t,a);a.push(this.process())}if("variable"===(null==(n=this.token)?void 0:n.type)&&(a.push(this.token.value),this.isUnary(t)))return this.node(t,a);if("operator"===(null==(e=this.token)?void 0:e.type)){if(this.isUnary(this.token.value)){a.push(this.process(this.token.value));continue}if(t){const o=a.slice(0);a.length=0,a.push(this.node(t,o))}t=this.token.value}this.lastIsVariable="variable"===(null==(r=this.token)?void 0:r.type)||this.lastIsVariable&&"boundary"===(null==(s=this.token)?void 0:s.type)}return this.node(t,a)}next(){return this.token=this.tokens.shift()}node(t,o){if(["->","<->","&","|","âˆ§","âˆ¨"].includes(t)&&2!==o.length)throw new b(`\n        Token "${t}": expected 2 variables, but received 1.\n      `);return"Â¬"===t||"!"===t?{operation:"Negation",value:o[0]}:"âˆ¨"===t||"|"===t?{operation:"Disjunction",left:o[0],right:o[1]}:"âˆ§"===t||"&"===t?{operation:"Conjunction",left:o[0],right:o[1]}:"->"===t?{operation:"Implication",left:o[0],right:o[1]}:"<->"===t?{operation:"Biconditional",left:o[0],right:o[1]}:o[0]}isUnary(t){return"Â¬"===t||"!"===t}};function C(t){const o=new E(t).lex();return new $(o).parse()}function N(t){return s.buildFormula(t)}function L(t){console.log(`[36m${t.headers.join("\t")}[0m`);for(let o=0;o<t.truthCombinations.length;o++){const i=t.truthCombinations[o],n=t.truthValues[o],e=i.map(t=>t?"[32mT[0m":"[31mF[0m").join("\t"),r=n?"[32mT[0m":"[31mF[0m";console.log(`${e}\t${r}`)}}function S(t,o){return{operation:"Implication",left:t,right:o}}function M(t,o){return{operation:"Biconditional",left:t,right:o}}function q(t,o){return{operation:"Conjunction",left:t,right:o}}function A(t,o){return{operation:"Disjunction",left:t,right:o}}function T(t){return{operation:"Negation",value:t}}exports.Parser=$;var k=exports.Calculator=class t{static generateTruthTable(o,i){if("string"==typeof o&&!y(o)){const i=C(o);return t.generateTruthTable(i,o)}const n=new Set;t.collectVariables(o,n);const e=Array.from(n),r=t.generateTruthCombinations(e.length),a={headers:[],truthCombinations:[],truthValues:[]};return e.forEach(t=>{a.headers.push(t)}),i=i||s.buildFormula(o),a.headers.push(i),r.forEach(i=>{const n={};e.forEach((t,o)=>{n[t]=!!i[o]}),a.truthCombinations.push(i);const r=t.evaluate(o,n);a.truthValues.push(r)}),a}static evaluate(o,i){if("string"==typeof o&&!y(o)){const n=C(o);return t.evaluate(n,i)}if("string"==typeof o)return i[`${o}`];if("Implication"===o.operation)return t.evaluateImplication(o,i);if("Biconditional"===o.operation)return t.evaluateBiconditional(o,i);if("Conjunction"===o.operation)return t.evaluateConjunction(o,i);if("Disjunction"===o.operation)return t.evaluateDisjunction(o,i);if("Negation"===o.operation)return t.evaluateNegation(o,i);throw new Error("Invalid formula operation")}static isSemanticConsequence(o,i){const n=new Set;let e;if("string"!=typeof i||y(i)||(i=C(i)),1===o.length)e="object"==typeof o[0]?o[0]:C(o[0]);else{g(o)||(o=o.map(t=>N(t))),e=C(D(o))}t.collectVariables(e,n);const r=Array.from(n),s=t.generateTruthCombinations(r.length);for(const a of s){const o={};if(r.forEach((t,i)=>{o[t]=!!a[i]}),t.evaluate(e,o)&&!t.evaluate(i,o))return!1}return!0}static evaluateImplication(o,i){const n=t.evaluate(o.left,i),e=t.evaluate(o.right,i);return!n||e}static evaluateBiconditional(o,i){const n=t.evaluate(o.left,i),e=t.evaluate(o.right,i);return n&&e||!n&&!e}static evaluateConjunction(o,i){const n=t.evaluate(o.left,i),e=t.evaluate(o.right,i);return n&&e}static evaluateDisjunction(o,i){const n=t.evaluate(o.left,i),e=t.evaluate(o.right,i);return n||e}static evaluateNegation(o,i){return!t.evaluate(o.value,i)}static generateTruthCombinations(t){const o=[],i=2**t;for(let n=0;n<i;n++){const i=n.toString(2).padStart(t,"0").split("").map(t=>"1"===t);o.push(i)}return o}static collectVariables(o,i){y(o)?i.add(o):p(o)?t.collectVariables(o.value,i):(t.collectVariables(o.left,i),t.collectVariables(o.right,i))}},F=class{static BiconditionalIntroduction(o,n){if((0,t.isDeepStrictEqual)(o.left,n.right)&&(0,t.isDeepStrictEqual)(o.right,n.left))return{operation:"Biconditional",left:o.left,right:o.right};const e=`Biconditional Introduction: cannot apply in ${N(o)} and ${N(n)}`;throw new i(e)}static BiconditionalElimination(t){return{operation:"Conjunction",left:{operation:"Implication",left:t.left,right:t.right},right:{operation:"Implication",left:t.right,right:t.left}}}static ConditionalProof(t,o){return{operation:"Implication",left:t,right:o}}static Conditionalization(o,n){if((0,t.isDeepStrictEqual)(o,n.right))return n;throw new i(`Conditionalization: cannot apply in ${N(n)} with ${N(o)}`)}static Commutativity(t){const o=t.right;return t.right=t.left,t.left=o,t}static Contraposition(t){return f({operation:"Implication",left:{operation:"Negation",value:t.right},right:{operation:"Negation",value:t.left}})}static ConjunctionIntroduction(t,o){return{operation:"Conjunction",left:t,right:o}}static ConjunctionElimination(t){return[t.left,t.right]}static DeMorgan(t){if(p(t)){if(l(t.value))return{operation:"Conjunction",left:{operation:"Negation",value:t.value.left},right:{operation:"Negation",value:t.value.right}};if(u(t.value))return{operation:"Disjunction",left:{operation:"Negation",value:t.value.left},right:{operation:"Negation",value:t.value.right}}}if(l(t)){if(!p(t.left)||!p(t.right))throw new i(`De Morgan: cannot apply in ${N(t)}`);return{operation:"Negation",value:{operation:"Conjunction",left:t.left.value,right:t.right.value}}}if(u(t)){if(!p(t.left)||!p(t.right))throw new i(`De Morgan: cannot apply in ${N(t)}`);return{operation:"Negation",value:{operation:"Disjunction",left:t.left.value,right:t.right.value}}}throw new i(`De Morgan: cannot apply in ${N(t)}`)}static DisjunctionIntroduction(o,n){if((0,t.isDeepStrictEqual)(n.left,o))return n;if((0,t.isDeepStrictEqual)(n.right,o))return n;const e=`Disjunction Introduction: cannot apply in ${N(n)} with ${N(o)}`;throw new i(e)}static DisjunctiveSyllogism(o,n){if((0,t.isDeepStrictEqual)(o.left,n.value))return o.right;if((0,t.isDeepStrictEqual)(o.right,n.value))return o.left;const e=`Disjunctive Syllogism: cannot apply in ${N(o)} with ${N(n)}`;throw new i(e)}static ImplicationElimination(t){return{operation:"Disjunction",left:{operation:"Negation",value:t.left},right:t.right}}static ImplicationNegation(t){if(!h(t.value))throw new i(`Implication Negation: cannot apply in ${N(t)}`);return{operation:"Conjunction",left:t.value.left,right:{operation:"Negation",value:t.value.right}}}static DoubleNegation(t){return f(t)}static DoubleNegationIntroduction(t){return{operation:"Negation",value:{operation:"Negation",value:t}}}static ConjunctionOverDisjunctionDistribution(t){return this.Distribute(t,l)}static DisjunctionOverConjunctionDistribution(t){return this.Distribute(t,u)}static ConjunctionAssociativity(t){return this.Associate(t,u)}static DisjunctionAssociativity(t){return this.Associate(t,l)}static BiconditionalAssociativity(t){return this.Associate(t,c)}static HypotheticalSyllogism(o,n){if((0,t.isDeepStrictEqual)(o.right,n.left))return{operation:"Implication",left:o.left,right:n.right};if((0,t.isDeepStrictEqual)(o.left,n.right))return{operation:"Implication",left:n.left,right:o.right};const e=`Hypothetical Syllogism: cannot apply in ${N(o)} with ${N(n)}`;throw new i(e)}static ModusPonens(o,n){if((0,t.isDeepStrictEqual)(o.left,n))return o.right;const e=`Modus Ponens: cannot apply in ${N(o)} with ${N(n)}`;throw new i(e)}static ModusTollens(o,n){if((0,t.isDeepStrictEqual)(o.right,n.value))return{operation:"Negation",value:o.left};const e=`Modus Tollens: cannot apply in ${N(o)} with ${N(n)}`;throw new i(e)}static ReductioAdAbsurdum(t){if(d(t.right))return{operation:"Negation",value:t.left};throw new i(`Reductio Ad Absurdum: cannot apply in ${t} with ${t.right}`)}static DistributeRecursively(t,o){try{return this.Distribute(t,o)}catch(i){return t}}static Distribute(t,o){let n,e;if(o(t.left))n=t.left,e=t.right;else{if(!o(t.right))throw new i(`Distribution: cannot apply in ${N(t)}`);n=t.right,e=t.left}let r={operation:n.operation,left:{operation:t.operation,left:e,right:n.left},right:{operation:t.operation,left:e,right:n.right}};return y(r.left)||(r.left=this.DistributeRecursively(r.left,o)),y(r.right)||(r.right=this.DistributeRecursively(r.right,o)),r}static Associate(t,o){let n,e;if(o(t.left))return n=t.left,e=t.right,{operation:t.operation,left:n.left,right:{operation:t.operation,left:n.right,right:e}};if(o(t.right))return n=t.right,e=t.left,{operation:t.operation,left:{operation:t.operation,left:e,right:n.left},right:n.right};throw new i(`Associativity: cannot apply in ${N(t)}`)}};exports.RuleSetter=F;var P=exports.RuleApplier=class o extends F{static biconditionalIntroduction(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=[n[e[0]].expression,n[e[1]].expression];if(!h(s[0])||!h(s[1]))throw new i(`Biconditional Introduction (Line ${r}): conditionals not found.`);const a=o.BiconditionalIntroduction(s[0],s[1]);return o.throwsIfIsNotEqual(a,t),a}static biconditionalElimination(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!c(s))throw new i(`Biconditional Elimination (Line ${r}): biconditional not found.`);const a=o.BiconditionalElimination(s);return o.throwsIfIsNotEqual(a,t),a}static conditionalization(t,n){const e=t.from[0],r=t.id;if(o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n),!h(t.expression))throw new i(`Conditionalization (Line ${r}): the formula is not an implication.`);const s=n[e[0]].expression;if("string"==typeof s&&!y(s))throw new i(`Conditionalization (Line ${r}): formula not found.`);const a=o.Conditionalization(s,t.expression);return o.throwsIfIsNotEqual(a,t),a}static conjunctionIntroduction(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if("string"==typeof s&&!y(s))throw new i(`Conjunction Introduction (Line ${r}): line ${e[0]} formula not found.`);const a=n[e[1]].expression;if("string"==typeof a&&!y(a))throw new i(`Conjunction Introduction (Line ${r}): line ${e[1]} formula not found.`);const c=o.ConjunctionIntroduction(s,a);return o.throwsIfIsNotEqual(c,t),c}static conjunctionElimination(n,e){const r=n.from[0],s=n.id;o.throwsIfLengthDoesntMatch(n,1,r.length),o.throwsIfIndexDoesntExist(r,e);const a=e[r[0]].expression;if(!u(a))throw new i(`Conjunction Elimination (Line ${s}): conjunction not found.`);const c=o.ConjunctionElimination(a);if(!(0,t.isDeepStrictEqual)(n.expression,c[0])&&!(0,t.isDeepStrictEqual)(n.expression,c[1]))throw new i(`Conjunction Elimination (Line ${s}): expected ${N(c[0])} or ${N(c[1])} but received ${N(n.expression)}`);return c}static commutativity(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!l(s)&&!u(s)&&!c(s))throw new i(`Commutativity (Line ${r}): cannot find any conjunction, biconditional or disjunction.`);const a=o.Commutativity(s);return o.throwsIfIsNotEqual(a,t),a}static contraposition(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!h(s))throw new i(`Contraposition (Line ${r}): implication not found.`);const a=o.Contraposition(s);return o.throwsIfIsNotEqual(a,t),a}static deMorgan(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!p(s)&&!u(s)&&!l(s))throw new i(`De Morgan (Line ${r}): formula is not a disjunction, conjunction or negation.`);const a=o.DeMorgan(s);return o.throwsIfIsNotEqual(a,t),a}static disjunctionIntroduction(t,n){const e=t.from[0],r=t.id;if(o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n),!l(t.expression))throw new i(`Disjunction Introduction (Line ${r}): expression is not a disjunction`);const s=n[e[0]].expression;if("string"==typeof s&&!y(s))throw new i(`Disjunction Introduction (Line ${r}): formula not found.`);const a=o.DisjunctionIntroduction(s,t.expression);return o.throwsIfIsNotEqual(a,t),a}static disjunctiveSyllogism(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression,a=n[e[1]].expression;let c,u,h;if(l(s)&&(u=s,c=a),l(a)&&(u=a,c=s),!u)throw new i(`Disjunctive Syllogism (Line ${r}): disjunction not found`);if(p(c)&&(h=c),!h)throw new i(`Disjunctive Syllogism (Line ${r}): negation not found`);const f=o.DisjunctiveSyllogism(u,h);return o.throwsIfIsNotEqual(f,t),f}static doubleNegation(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if("string"==typeof s&&!y(s))throw new i(`Double Negation (Line ${r}): formula not found.`);const a=o.DoubleNegation(s);return o.throwsIfIsNotEqual(a,t),a}static doubleNegationIntroduction(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if("string"==typeof s&&!y(s))throw new i(`Double Negation Introduction (Line ${r}): negation not found.`);const a=o.DoubleNegationIntroduction(s);return o.throwsIfIsNotEqual(a,t),a}static hypotheticalSyllogism(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression,a=n[e[1]].expression;if(!h(s)||!h(a))throw new i(`Hypothetical Syllogism (Line ${r}): both formulas should be conditionals.`);const c=o.HypotheticalSyllogism(s,a);return o.throwsIfIsNotEqual(c,t),c}static implicationElimination(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!h(s))throw new i(`Implication Elimination (Line ${r}): implication not found.`);const a=o.ImplicationElimination(s);return o.throwsIfIsNotEqual(a,t),a}static implicationNegation(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);let s=n[e[0]].expression;if(!p(s))throw new i(`Implication Negation (Line ${r}): negation not found`);const a=o.ImplicationNegation(s);return o.throwsIfIsNotEqual(a,t),a}static modusPonens(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);let s,a,c=n[e[0]].expression,u=n[e[1]].expression;if(h(c)&&(a=c,s=u),h(u)&&(a=u,s=c),!a)throw new i(`Modus Ponens (Line ${r}): implication not found`);const l=s;if(!y(l)&&"string"==typeof l)throw new i(`Modus Ponens (Line ${r}): antecedent not found`);const p=o.ModusPonens(a,l);return o.throwsIfIsNotEqual(p,t),p}static modusTollens(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression,a=n[e[1]].expression;let c,u;if(h(s)&&(u=s,c=a),h(a)&&(u=a,c=s),!u)throw new i(`Modus Tollens (Line ${r}): implication not found`);const l=c;if(!p(l))throw new i(`Modus Tollens (Line ${r}): negated consequent not found`);const f=o.ModusTollens(u,l);return o.throwsIfIsNotEqual(f,t),f}static conjunctionOverDisjunctionDistribution(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!u(s))throw new i(`Distribution (Line ${r}): conjunction not found.`);const a=o.ConjunctionOverDisjunctionDistribution(s);return o.throwsIfIsNotEqual(a,t),a}static disjunctionOverConjunctionDistribution(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!l(s))throw new i(`Distribution (Line ${r}): disjunction not found.`);const a=o.DisjunctionOverConjunctionDistribution(s);return o.throwsIfIsNotEqual(a,t),a}static conjunctionAssociativity(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!u(s))throw new i(`Associativity (Line ${r}): conjunction not found.`);const a=o.ConjunctionAssociativity(s);return o.throwsIfIsNotEqual(a,t),a}static disjunctionAssociativity(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!l(s))throw new i(`Associativity (Line ${r}): disjunction not found.`);const a=o.DisjunctionAssociativity(s);return o.throwsIfIsNotEqual(a,t),a}static biconditionalAssociativity(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!c(s))throw new i(`Associativity (Line ${r}): disjunction not found.`);const a=o.BiconditionalAssociativity(s);return o.throwsIfIsNotEqual(a,t),a}static conditionalProof(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,2,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]],a=n[e[1]];if(!y(a.expression)&&"string"==typeof a.expression)throw new i(`Conditional Proof (Line ${r}): cannot find a formula at line ${a.id}`);if(!y(s.expression)&&"string"==typeof s.expression)throw new i(`Conditional Proof (Line ${r}): cannot find a formula at line ${s.id}`);let c,u;if(w(s)&&I(a)){if(c=s.expression,a.hypothesisId!=s.id)throw new i(`Conditional Proof (Line ${r}): end of hypothesis references line ${a.hypothesisId} hypothesis, but received line ${s.id} hypothesis`);u=a.expression}else{if(!w(a)||!I(s))throw new i("Conditional Proof: end of hypothesis or hypothesis not found.");if(c=a.expression,s.hypothesisId!=a.id)throw new i(`Conditional Proof (Line ${r}): end of hypothesis references line ${s.hypothesisId} hypothesis, but received line ${a.id} hypothesis`);u=s.expression}const l=o.ConditionalProof(c,u);return o.throwsIfIsNotEqual(l,t),l}static reductioAdAbsurdum(t,n){const e=t.from[0],r=t.id;o.throwsIfLengthDoesntMatch(t,1,e.length),o.throwsIfIndexDoesntExist(e,n);const s=n[e[0]].expression;if(!h(s))throw new i(`Reductio Ad Absurdum (Line ${r}): conditional not found.`);const a=o.ReductioAdAbsurdum(s);return o.throwsIfIsNotEqual(a,t),a}static throwsIfIsNotEqual(o,n){const e=n.expression,r=n.from[1];if(!(0,t.isDeepStrictEqual)(o,e))throw new i(`\n        ${r} (Line ${n.id}): expected ${N(o)} but received ${N(e)}\n      `)}static throwsIfLengthDoesntMatch(t,o,n){const e=t.from[1],r=t.id;if(o!==n)throw new i(`${e} (Line ${r}): expect ${o} formulas to apply the rule but received ${n}.`)}static throwsIfIndexDoesntExist(t,o){t.forEach(t=>{if(!o[t])throw new i(`Cannot find a formula at index ${t}`)})}},B=exports.inferenceRulesMap={"Associativity (Biconditional)":P.biconditionalAssociativity,"Associativity (Conjunction)":P.conjunctionAssociativity,"Associativity (Disjunction)":P.disjunctionAssociativity,"Biconditional Elimination":P.biconditionalElimination,"Biconditional Introduction":P.biconditionalIntroduction,Commutativity:P.commutativity,"Conditional Proof":P.conditionalProof,Conditionalization:P.conditionalization,Contraposition:P.contraposition,"Conjunction Elimination":P.conjunctionElimination,"Conjunction Introduction":P.conjunctionIntroduction,"De Morgan":P.deMorgan,"Disjunction Introduction":P.disjunctionIntroduction,"Disjunctive Syllogism":P.disjunctiveSyllogism,"Distribution (Conjunction over Disjunction)":P.conjunctionOverDisjunctionDistribution,"Distribution (Disjunction over Conjunction)":P.disjunctionOverConjunctionDistribution,"Double Negation":P.doubleNegation,"Double Negation Introduction":P.doubleNegationIntroduction,"Hypothetical Syllogism":P.hypotheticalSyllogism,"Implication Elimination":P.implicationElimination,"Implication Negation":P.implicationNegation,"Modus Ponens":P.modusPonens,"Modus Tollens":P.modusTollens,"Reductio Ad Absurdum":P.reductioAdAbsurdum},O=exports.ProofChecker=class t{static check(o){const i=t.createMappedProof(o);let n,e=[];return Object.keys(i).forEach((r,s)=>{const a=i[s+1];if(x(a)){const[n,e]=a.from;t.validateScope(n,a,i),B[e](a,o),console.log("[32m",`Applied ${e} with success at line ${a.id} âœ”ï¸`)}"Premise"===a.type&&e.push(a.expression),"Conclusion"===a.type&&(n=N(a.expression)),e=e.map(t=>N(t))}),console.log("[0m",`\n{ ${e.join(", ")} } âŠ¢ ${n}`),!0}static createMappedProof(t){let o=0,i=0;return Object.keys(t).forEach((n,e)=>{const r=t[++e];if(w(r))i++,o++,t[e].scopeIdx=[o,i];else if(I(r)){const i=t[r.hypothesisId].scopeIdx[1];t[e].scopeIdx=[o,i],o--}else if(t[e].scopeIdx=0===o?[0,0]:[o,i],0!==o&&"Conclusion"===t[e].type)throw new Error(`(Line ${e}): You cannot put your conclusion inside of a hypothesis.`)}),t}static validateScope(t,o,n){t.forEach(t=>{const[e,r]=n[o.id].scopeIdx,[s,a]=n[t].scopeIdx,[,c]=o.from;if(e<s&&r!=a&&"Conditional Proof"!=c)throw new i(`Scope Error: cannot access line ${t} by the ${o.id} line.`)})}},V=class{static reduceFormula(t){if("string"==typeof t)return t;switch(t.operation){case"Biconditional":return this.biconditional(t);case"Implication":return this.implication(t);case"Conjunction":return this.conjunction(t);case"Disjunction":return this.disjunction(t);case"Negation":return this.negation(t);default:throw new Error("Invalid operation")}}static biconditional(t){const o=this.reduceFormula(t.left),i=this.reduceFormula(t.right);return{operation:"Conjunction",left:this.reduceFormula({operation:"Implication",left:o,right:i}),right:this.reduceFormula({operation:"Implication",left:i,right:o})}}static implication(t){return{operation:"Disjunction",left:{operation:"Negation",value:this.reduceFormula(t.left)},right:this.reduceFormula(t.right)}}static conjunction(t){return{operation:"Conjunction",left:this.reduceFormula(t.left),right:this.reduceFormula(t.right)}}static disjunction(t){return{operation:"Disjunction",left:this.reduceFormula(t.left),right:this.reduceFormula(t.right)}}static negation(t){return{operation:"Negation",value:this.reduceFormula(t.value)}}};exports.Reducer=V;var R=class{constructor(){this.builder=s,this.reducer=V,this.calculator=k,this.proofChecker=O,this.parse={toFormulaObject:t=>{const o=new E(t).lex();return new $(o).parse()},toFormulaString:t=>this.builder.buildFormula(t)},this.verifyConsequence={semantic:this.calculator.isSemanticConsequence,syntactic:()=>{}},this.reduce=(t=>{if("string"==typeof t){let o=this.parse.toFormulaObject(t);return o=this.reducer.reduceFormula(o),this.parse.toFormulaString(o)}let o=t.operation.toLocaleLowerCase();return this.reducer[o](t)}),this.evaluate=this.calculator.evaluate,this.generateTruthTable=this.calculator.generateTruthTable,this.checkProof=this.proofChecker.check,this.isTautology=(t=>{const{truthValues:o}=this.calculator.generateTruthTable(t);for(let i=0;i<o.length;i++)if(!o[i])return!1;return!0}),this.isContradiction=(t=>{const{truthValues:o}=this.calculator.generateTruthTable(t);for(let i=0;i<o.length;i++)if(o[i])return!1;return!0}),this.isContingency=(t=>{let o;const{truthValues:i}=this.calculator.generateTruthTable(t);o=i[0];for(let n=1;n<i.length;n++)if(i[n]!=o)return!0;return!1})}};exports.Frege=R;var z=exports.frege=new R;
},{"util":"wqTM"}],"mpVp":[function(require,module,exports) {
"use strict";var t=require("fregejs");function e(t){document.getElementById("resultado").textContent+=t}function n(t){return/^[~^vâ†’â†”]+$/.test(t)}function o(t){try{return new Function("return "+t),!0}catch(e){return!1}}function r(t,e){document.getElementById("results").innerHTML="\n    <p>FÃ³rmula: ".concat(t,"</p>\n    <p>Provador de Tautologia: ").concat(e?"Ã‰ uma tautologia":"NÃ£o Ã© uma tautologia","</p>\n\n  ")}function a(t){document.getElementById("results").innerHTML="\n    <p>Sua fÃ³rmula estÃ¡ incorreta: ".concat(t,"</p>\n  ")}function c(e){var n=e;e=(e=(e=e.replace(/~/g,"Â¬")).replace(/â†’/g,"->")).replace(/â†”/g,"<->");try{u(t.frege.generateTruthTable(e)),r(n,t.frege.isTautology(e))}catch(o){console.log(o),a(n)}}function u(t){var e='<table class="tabela-verdade">';e+="<tr>",t.headers.forEach(function(t){e+="<th>".concat(t,"</th>")}),e+="</tr>";for(var n=0;n<t.truthCombinations.length;n++){e+="<tr>",t.truthCombinations[n].forEach(function(t){e+='<td class="tabela-verdade">'.concat(t?"<span style='color:green'>T</span>":"<span style='color:red'>F</span>","</td>")});var o=t.truthValues[n]?"<span style='color:green'>T</span>":"<span style='color:red'>F</span>";e+='<td class="tabela-verdade">'.concat(o,"</td>"),e+="</tr>"}e+="</table>",document.getElementById("tabela").innerHTML=e}document.querySelectorAll(".logic-button").forEach(function(t){t.addEventListener("click",function(){e(this.textContent)})}),document.querySelectorAll(".button").forEach(function(t){t.addEventListener("click",function(){if("DEL"===this.textContent)(t=document.getElementById("resultado")).textContent=t.textContent.slice(0,-1);else if("AC"===this.textContent){var t;(t=document.getElementById("resultado")).textContent=""}})}),document.addEventListener("keydown",function(t){"Backspace"===t.key?deleteChar():"ArrowLeft"===t.key?moveCursorLeft():"ArrowRight"===t.key?moveCursorRight():t.preventDefault()}),document.querySelector(".button-calc").addEventListener("click",function(){c(document.getElementById("resultado").textContent)});
},{"fregejs":"ommy"}]},{},["mpVp"], null)
//# sourceMappingURL=/script.2e6ad075.js.map