{"version":3,"sources":["node_modules/util/support/isBufferBrowser.js","node_modules/util/node_modules/inherits/inherits_browser.js","node_modules/process/browser.js","node_modules/util/util.js","node_modules/fregejs/dist/index.mjs","script.js"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","getOwnPropertyDescriptors","Object","obj","keys","descriptors","getOwnPropertyDescriptor","formatRegExp","format","f","isString","objects","inspect","join","str","String","replace","x","Number","JSON","stringify","_","isNull","isObject","deprecate","fn","msg","noDeprecation","warned","throwDeprecation","traceDeprecation","console","trace","error","debugEnviron","debugs","opts","ctx","seen","stylize","stylizeNoColor","depth","colors","isBoolean","showHidden","_extend","isUndefined","customInspect","stylizeWithColor","formatValue","styleType","style","styles","arrayToHash","hash","forEach","val","idx","value","recurseTimes","isFunction","constructor","ret","primitive","formatPrimitive","visibleKeys","getOwnPropertyNames","isError","indexOf","formatError","isRegExp","RegExp","toString","isDate","Date","output","base","braces","isArray","toUTCString","formatArray","map","key","formatProperty","pop","reduceToSingleString","simple","isNumber","l","hasOwnProperty","match","desc","get","set","split","line","substr","reduce","prev","cur","numLinesEst","ar","arg","isNullOrUndefined","isSymbol","re","objectToString","d","isPrimitive","o","pad","n","debuglog","toUpperCase","test","pid","isBuffer","require","months","timestamp","time","getHours","getMinutes","getSeconds","getDate","getMonth","prop","log","inherits","origin","add","kCustomPromisifiedSymbol","Symbol","undefined","callbackifyOnRejected","reason","cb","newReason","callbackify","original","TypeError","callbackified","maybeCb","self","then","rej","setPrototypeOf","getPrototypeOf","defineProperties","promisify","defineProperty","enumerable","writable","configurable","promiseResolve","promiseReject","promise","Promise","resolve","reject","err","custom","_util","InvalidFormulaException","InferenceException","InvalidProofSequenceException","UnrecognizedTokenException","_Builder","left","right","formula","operation","buildFormula","operations","buildRecursively","Biconditional","biconditional","Conjunction","conjunction","Disjunction","disjunction","Implication","implication","Builder","isBinaryOperationFormula","isBiconditional","isConjunction","isDisjunction","isImplication","isNegation","eliminateDoubleNegations","innerValue","isContradiction","firstCondition","isDeepStrictEqual","secondCondition","isArrayString","every","item","isHypothesis","type","isEndOfHypothesis","isMolecularFormula","isProofItemInferred","includes","propositionalVariablesList","isPropositionalVariable","buildConjunctionString","premises","premise","haveEvenNumberOfNegations","Lexer","tokens","pointer","operator","input","lex","next","isSpecial","c","operatorExists","throwTokenException","isWhiteSpace","isVariable","isExpressionBoundary","token","op","position","SyntaxException","Parser","lastIsVariable","parse","_a","_b","_c","_d","_e","_f","node","isUnary","tmp","slice","shift","parseToFormulaObject","parseToFormulaString","printTruthTable","truthTable","headers","truthCombinations","combination","values","truthValues","formattedCombination","formattedValue","negation","Calculator","_Calculator","stringfiedFormula","parsedFormula","generateTruthTable","variables","Set","collectVariables","variableArray","from","generateTruthCombinations","table","variable","index","result","evaluate","evaluateImplication","evaluateBiconditional","evaluateConjunction","evaluateDisjunction","evaluateNegation","conclusion","conjunctionOfPremises","numVariables","combinations","totalCombinations","padStart","bit","RuleSetter","conditional1","conditional2","isDeepStrictEqual2","errorMsg","biconditional2","hypothesis","conclusionOfHypothesis","conditional","formula1","formula2","conjunction2","disjunction2","negatedDisjunct","negation2","Distribute","Associate","antecedent","negatedConsequent","isK","KFormula","otherFormula","distributedFormula","DistributeRecursively","isT","mainFormula","RuleApplier","_RuleApplier","proof","requiredItens","id","throwsIfLengthDoesntMatch","throwsIfIndexDoesntExist","formulas","expression","inferenceResult","BiconditionalIntroduction","throwsIfIsNotEqual","requiredItem","BiconditionalElimination","Conditionalization","firstFormula","secondFormula","ConjunctionIntroduction","inferenceResults","ConjunctionElimination","isDeepStrictEqual3","Commutativity","Contraposition","DeMorgan","DisjunctionIntroduction","remainingFormula","DisjunctiveSyllogism","DoubleNegation","DoubleNegationIntroduction","HypotheticalSyllogism","ImplicationElimination","ImplicationNegation","implication2","ModusPonens","consequent","ModusTollens","ConjunctionOverDisjunctionDistribution","DisjunctionOverConjunctionDistribution","ConjunctionAssociativity","DisjunctionAssociativity","BiconditionalAssociativity","item1","item2","endOfHypothesis","hypothesisId","ConditionalProof","ReductioAdAbsurdum","expectedFormula","actualItem","actualFormula","inferenceMethod","expected","received","rule","inferenceRulesMap","biconditionalAssociativity","conjunctionAssociativity","disjunctionAssociativity","biconditionalElimination","biconditionalIntroduction","commutativity","conditionalProof","conditionalization","contraposition","conjunctionElimination","conjunctionIntroduction","deMorgan","disjunctionIntroduction","disjunctiveSyllogism","conjunctionOverDisjunctionDistribution","disjunctionOverConjunctionDistribution","doubleNegation","doubleNegationIntroduction","hypotheticalSyllogism","implicationElimination","implicationNegation","modusPonens","modusTollens","reductioAdAbsurdum","ProofChecker","_ProofChecker","mappedProof","createMappedProof","inferenceRule","validateScope","layerIdx","blockIdx","itemBlockIdx","requiredItemId","actualLayer","actualBlock","scopeIdx","requiredLayer","requiredBlock","Reducer","reduceFormula","Frege","builder","reducer","calculator","proofChecker","toFormulaObject","toFormulaString","verifyConsequence","semantic","isSemanticConsequence","syntactic","formulaObject","toLocaleLowerCase","checkProof","check","isTautology","isContingency","firstTruthValue","frege","_fregejs","insert","text","document","getElementById","textContent","analiseLexica","analisadorSintatico","Function","exibirResultados","tautologia","innerHTML","exibirErro","calcularExpressaoLogica","expressao","expressaoNaoTratada","generateHTMLTruthTable","htmlTable","header","querySelectorAll","button","addEventListener","telinha","event","deleteChar","moveCursorLeft","moveCursorRight","preventDefault","querySelector"],"mappings":"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","file":"script.2e6ad075.js","sourceRoot":"..","sourcesContent":["module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","// src/exceptions/invalid-formula.exception.ts\nvar InvalidFormulaException = class extends Error {\n};\n\n// src/exceptions/invalid-inference.exception.ts\nvar InferenceException = class extends Error {\n};\n\n// src/exceptions/invalid-proof-sequence.exception.ts\nvar InvalidProofSequenceException = class extends Error {\n};\n\n// src/exceptions/unrecognized-token.exception.ts\nvar UnrecognizedTokenException = class extends Error {\n};\n\n// src/builder/Builder.ts\nvar _Builder = class _Builder {\n  static biconditional(left, right) {\n    return `(${left} <-> ${right})`;\n  }\n  static conjunction(left, right) {\n    return `(${left} \\u2227 ${right})`;\n  }\n  static disjunction(left, right) {\n    return `(${left} \\u2228 ${right})`;\n  }\n  static implication(left, right) {\n    return `(${left} -> ${right})`;\n  }\n  static buildRecursively(formula) {\n    if (typeof formula === \"string\")\n      return formula;\n    if (\"operation\" in formula && formula.operation === \"Negation\")\n      return `\\xAC(${this.buildFormula(formula.value)})`;\n    if (!(\"operation\" in formula))\n      throw new InvalidFormulaException(\"Invalid Formula.\");\n    const left = this.buildFormula(formula.left);\n    const right = this.buildFormula(formula.right);\n    const operation = formula.operation;\n    return this.operations[operation](left, right);\n  }\n  /**\n   * Builds a formula with the syntax of logic.\n   * @param formula - The logical formula to build.\n   * @returns The builded logical formula.\n   * @throws {InvalidFormulaException}\n   */\n  static buildFormula(formula) {\n    const result = this.buildRecursively(formula);\n    return result;\n  }\n};\n_Builder.operations = {\n  Biconditional: _Builder.biconditional,\n  Conjunction: _Builder.conjunction,\n  Disjunction: _Builder.disjunction,\n  Implication: _Builder.implication\n};\nvar Builder = _Builder;\n\n// src/utils/isBinaryOperation.ts\nfunction isBinaryOperationFormula(formula) {\n  return !!(formula.operation && formula.left && formula.right);\n}\n\n// src/utils/isBiconditional.ts\nfunction isBiconditional(formula) {\n  return formula.operation === \"Biconditional\" && isBinaryOperationFormula(formula);\n}\n\n// src/utils/isConjunction.ts\nfunction isConjunction(formula) {\n  return formula.operation === \"Conjunction\" && isBinaryOperationFormula(formula);\n}\n\n// src/utils/isDisjunction.ts\nfunction isDisjunction(formula) {\n  return formula.operation === \"Disjunction\" && isBinaryOperationFormula(formula);\n}\n\n// src/utils/isImplication.ts\nfunction isImplication(formula) {\n  return formula.operation === \"Implication\" && isBinaryOperationFormula(formula);\n}\n\n// src/utils/isContradiction.ts\nimport { isDeepStrictEqual } from \"util\";\n\n// src/utils/isNegation.ts\nfunction isNegation(formula) {\n  return formula.operation === \"Negation\" && !!formula.value;\n}\n\n// src/utils/eliminateDoubleNegation.ts\nfunction eliminateDoubleNegations(formula) {\n  if (isNegation(formula)) {\n    const innerValue = formula.value;\n    if (isNegation(innerValue)) {\n      return eliminateDoubleNegations(innerValue.value);\n    }\n    return {\n      operation: \"Negation\",\n      value: eliminateDoubleNegations(innerValue)\n    };\n  }\n  if (isBinaryOperationFormula(formula)) {\n    return {\n      operation: formula.operation,\n      left: eliminateDoubleNegations(formula.left),\n      right: eliminateDoubleNegations(formula.right)\n    };\n  }\n  return formula;\n}\n\n// src/utils/isContradiction.ts\nfunction isContradiction(formula) {\n  formula = eliminateDoubleNegations(formula);\n  const firstCondition = isDeepStrictEqual(formula, {\n    operation: \"Conjunction\",\n    left: formula.left,\n    right: { operation: \"Negation\", value: formula.left }\n  });\n  const secondCondition = isDeepStrictEqual(formula, {\n    operation: \"Conjunction\",\n    left: { operation: \"Negation\", value: formula.right },\n    right: formula.right\n  });\n  return firstCondition || secondCondition;\n}\n\n// src/utils/isArrayString.ts\nfunction isArrayString(array) {\n  return array.every((item) => typeof item === \"string\");\n}\n\n// src/utils/isHypothesis.ts\nfunction isHypothesis(x) {\n  return x.type === \"Hypothesis\";\n}\n\n// src/utils/isEndOfHypothesis.ts\nfunction isEndOfHypothesis(x) {\n  return x.type === \"End of Hypothesis\";\n}\n\n// src/utils/isMolecularFormula.ts\nfunction isMolecularFormula(formula) {\n  if (typeof formula === \"string\")\n    return false;\n  if (formula.operation === \"Negation\")\n    return false;\n  return true;\n}\n\n// src/utils/isProofItemInferred.ts\nfunction isProofItemInferred(x) {\n  if (!(x == null ? void 0 : x.type))\n    return false;\n  return [\"Knowledge\", \"End of Hypothesis\", \"Conclusion\"].includes(x.type);\n}\n\n// src/utils/isPropositionalVariable.ts\nvar propositionalVariablesList = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\"\n];\nfunction isPropositionalVariable(formula) {\n  return typeof formula === \"string\" && propositionalVariablesList.includes(formula);\n}\n\n// src/utils/buildConjunctionString.ts\nfunction buildConjunctionString(premises) {\n  const conjunctionFormulaArray = premises.map(\n    (premise) => `(${premise})`\n  );\n  const conjunctionFormulaString = conjunctionFormulaArray.join(\"\\u2227\");\n  return conjunctionFormulaString;\n}\n\n// src/utils/haveEvenNumberOfNegations.ts\nfunction haveEvenNumberOfNegations(formula) {\n  if (!isNegation(formula))\n    return true;\n  formula = eliminateDoubleNegations(formula);\n  return !isNegation(formula);\n}\n\n// src/lexer/Lexer.ts\nvar Lexer = class {\n  /**\n   * Creates a new Lexer instance.\n   * @param formula The propositional logic formula to tokenize.\n   */\n  constructor(formula) {\n    this.tokens = [];\n    this.pointer = 0;\n    this.operator = \"\";\n    this.input = formula;\n  }\n  /**\n   * Tokenizes the propositional logic formula.\n   * @returns An array of tokens representing the formula.\n   */\n  lex() {\n    while (this.next()) {\n      if (this.isSpecial(this.c)) {\n        this.operator += this.c;\n        if (this.operatorExists(this.operator)) {\n          this.push({\n            type: \"operator\",\n            value: this.operator\n          });\n          this.operator = \"\";\n        }\n      } else {\n        if (this.operator)\n          this.throwTokenException(\n            this.operator,\n            this.pointer - this.operator.length - 1\n          );\n        else if (this.isWhiteSpace(this.c))\n          continue;\n        else if (this.isVariable(this.c))\n          this.push({ type: \"variable\", value: this.c });\n        else if (this.isExpressionBoundary(this.c))\n          this.push({ type: \"boundary\", value: this.c });\n        else\n          this.throwTokenException(this.c, this.pointer - 2);\n      }\n    }\n    return this.tokens;\n  }\n  next() {\n    return this.c = this.input[this.pointer++];\n  }\n  push(token) {\n    this.tokens.push({\n      type: token.type,\n      value: token.value\n    });\n  }\n  isWhiteSpace(c) {\n    return /\\s/.test(c);\n  }\n  isVariable(c) {\n    return /[A-Z]/.test(c);\n  }\n  isSpecial(c) {\n    return /[¬∧∨&!|\\-><->]/.test(c);\n  }\n  isExpressionBoundary(c) {\n    return /[\\(\\)]/.test(c);\n  }\n  operatorExists(op) {\n    return [\"\\xAC\", \"!\", \"\\u2227\", \"&\", \"\\u2228\", \"|\", \"->\", \"<->\"].indexOf(op) !== -1;\n  }\n  throwTokenException(token, position) {\n    throw new UnrecognizedTokenException(\n      `Unrecognized token \"${token}\" on position ${position}`\n    );\n  }\n};\n\n// src/exceptions/syntax-error.exception.ts\nvar SyntaxException = class extends Error {\n};\n\n// src/parser/Parser.ts\nvar Parser = class {\n  /**\n   * Constructor of the Parser class.\n   * @param tokens Array of tokens to be analyzed.\n   */\n  constructor(tokens) {\n    this.lastIsVariable = false;\n    this.tokens = JSON.parse(JSON.stringify(tokens));\n  }\n  /**\n   * Performs the analysis of the tokens and returns the logical formula tree.\n   * @returns The logical formula resulting from the analysis of the tokens.\n   */\n  parse() {\n    return this.process();\n  }\n  process(operation) {\n    var _a, _b, _c, _d, _e, _f;\n    operation = operation || null;\n    const args = [];\n    while (this.next()) {\n      if (this.lastIsVariable && ((_a = this.token) == null ? void 0 : _a.type) === \"variable\")\n        throw new SyntaxException(\n          `Token \"${this.token.value}\": Expected one variable, but received more than 1.`\n        );\n      if (this.token === void 0)\n        break;\n      if (((_b = this.token) == null ? void 0 : _b.type) === \"boundary\") {\n        if (this.token.value === \")\")\n          return this.node(operation, args);\n        args.push(this.process());\n      }\n      if (((_c = this.token) == null ? void 0 : _c.type) === \"variable\") {\n        args.push(this.token.value);\n        if (this.isUnary(operation))\n          return this.node(operation, args);\n      }\n      if (((_d = this.token) == null ? void 0 : _d.type) === \"operator\") {\n        if (this.isUnary(this.token.value)) {\n          args.push(this.process(this.token.value));\n          continue;\n        }\n        if (operation) {\n          const tmp = args.slice(0);\n          args.length = 0;\n          args.push(this.node(operation, tmp));\n        }\n        operation = this.token.value;\n      }\n      this.lastIsVariable = ((_e = this.token) == null ? void 0 : _e.type) === \"variable\" || this.lastIsVariable && ((_f = this.token) == null ? void 0 : _f.type) === \"boundary\";\n    }\n    return this.node(operation, args);\n  }\n  next() {\n    return this.token = this.tokens.shift();\n  }\n  node(operator, args) {\n    if ([\"->\", \"<->\", \"&\", \"|\", \"\\u2227\", \"\\u2228\"].includes(operator)) {\n      if (args.length !== 2)\n        throw new SyntaxException(`\n        Token \"${operator}\": expected 2 variables, but received 1.\n      `);\n    }\n    if (operator === \"\\xAC\" || operator === \"!\")\n      return { operation: \"Negation\", value: args[0] };\n    if (operator === \"\\u2228\" || operator === \"|\")\n      return {\n        operation: \"Disjunction\",\n        left: args[0],\n        right: args[1]\n      };\n    if (operator === \"\\u2227\" || operator === \"&\")\n      return {\n        operation: \"Conjunction\",\n        left: args[0],\n        right: args[1]\n      };\n    if (operator === \"->\")\n      return {\n        operation: \"Implication\",\n        left: args[0],\n        right: args[1]\n      };\n    if (operator === \"<->\")\n      return {\n        operation: \"Biconditional\",\n        left: args[0],\n        right: args[1]\n      };\n    return args[0];\n  }\n  isUnary(operator) {\n    return operator === \"\\xAC\" || operator === \"!\";\n  }\n};\n\n// src/utils/parse.ts\nfunction parseToFormulaObject(formula) {\n  const tokens = new Lexer(formula).lex();\n  return new Parser(tokens).parse();\n}\nfunction parseToFormulaString(formula) {\n  return Builder.buildFormula(formula);\n}\n\n// src/utils/printTruthTable.ts\nfunction printTruthTable(truthTable) {\n  console.log(`\\x1B[36m${truthTable.headers.join(\"\t\")}\\x1B[0m`);\n  for (let i = 0; i < truthTable.truthCombinations.length; i++) {\n    const combination = truthTable.truthCombinations[i];\n    const values = truthTable.truthValues[i];\n    const formattedCombination = combination.map((value) => value ? \"\\x1B[32mT\\x1B[0m\" : \"\\x1B[31mF\\x1B[0m\").join(\"\t\");\n    const formattedValue = values ? \"\\x1B[32mT\\x1B[0m\" : \"\\x1B[31mF\\x1B[0m\";\n    console.log(`${formattedCombination}\t${formattedValue}`);\n  }\n}\n\n// src/utils/objectBuilder.ts\nfunction implication(left, right) {\n  let implication2 = { operation: \"Implication\", left, right };\n  return implication2;\n}\nfunction biconditional(left, right) {\n  let biconditional2 = { operation: \"Biconditional\", left, right };\n  return biconditional2;\n}\nfunction conjunction(left, right) {\n  let conjunction2 = { operation: \"Conjunction\", left, right };\n  return conjunction2;\n}\nfunction disjunction(left, right) {\n  let disjunction2 = { operation: \"Disjunction\", left, right };\n  return disjunction2;\n}\nfunction negation(value) {\n  let negation2 = { operation: \"Negation\", value };\n  return negation2;\n}\n\n// src/calculator/Calculator.ts\nvar Calculator = class _Calculator {\n  /**\n   * Generates a truth table for the given formula.\n   *\n   * @param formula - The logical formula to generate a truth table for.\n   * @param stringfiedFormula - An optional string representation of the formula.\n   * @returns The truth table as an array containing headers, truth combinations, and results.\n   *\n   * @example\n   * const output = Calculator.generateTruthTable('P -> Q');\n   * console.log(output);\n   * // Output:\n   * // {\n   * //   headers: ['P', 'Q', '(P -> Q)'],\n   * //   truthCombinations: [\n   * //     [false, false], [false, true],\n   * //     [true, false], [true, true]\n   * //   ],\n   * //   truthValues: [true, true, false, true]\n   * // }\n   */\n  static generateTruthTable(formula, stringfiedFormula) {\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula)) {\n      const parsedFormula = parseToFormulaObject(formula);\n      return _Calculator.generateTruthTable(parsedFormula, formula);\n    }\n    const variables = /* @__PURE__ */ new Set();\n    _Calculator.collectVariables(formula, variables);\n    const variableArray = Array.from(variables);\n    const truthCombinations = _Calculator.generateTruthCombinations(\n      variableArray.length\n    );\n    const table = {\n      headers: [],\n      truthCombinations: [],\n      truthValues: []\n    };\n    variableArray.forEach((variable) => {\n      table.headers.push(variable);\n    });\n    stringfiedFormula = stringfiedFormula || Builder.buildFormula(formula);\n    table.headers.push(stringfiedFormula);\n    truthCombinations.forEach((combination) => {\n      const values = {};\n      variableArray.forEach((variable, index) => {\n        values[variable] = !!combination[index];\n      });\n      table.truthCombinations.push(combination);\n      const result = _Calculator.evaluate(formula, values);\n      table.truthValues.push(result);\n    });\n    return table;\n  }\n  /**\n   * Evaluates the given logical formula with the provided truth values for variables.\n   *\n   * @param formula - The logical formula to evaluate.\n   * @param values - An object representing truth values for propositional variables.\n   * @returns The result of the evaluation (true or false).\n   *\n   * @example\n   * const result = Calculator.evaluate('P -> Q', { P: true, Q: false });\n   * console.log(result); // Output: false\n   */\n  static evaluate(formula, values) {\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula)) {\n      const parsedFormula = parseToFormulaObject(formula);\n      return _Calculator.evaluate(parsedFormula, values);\n    }\n    if (typeof formula === \"string\")\n      return values[`${formula}`];\n    if (formula.operation === \"Implication\") {\n      return _Calculator.evaluateImplication(formula, values);\n    }\n    if (formula.operation === \"Biconditional\") {\n      return _Calculator.evaluateBiconditional(formula, values);\n    }\n    if (formula.operation === \"Conjunction\") {\n      return _Calculator.evaluateConjunction(formula, values);\n    }\n    if (formula.operation === \"Disjunction\") {\n      return _Calculator.evaluateDisjunction(formula, values);\n    }\n    if (formula.operation === \"Negation\") {\n      return _Calculator.evaluateNegation(formula, values);\n    }\n    throw new Error(\"Invalid formula operation\");\n  }\n  /**\n   * Checks if a given formula is a semantic consequence of the given premises.\n   * A semantic consequence holds if, in every possible truth assignment to the propositional variables,\n   * when all premises are true, the conclusion is also true.\n   *\n   * @param premises - An array of logical formulas or strings representing the premises.\n   * @param conclusion - The conclusion formula to check as a semantic consequence.\n   * @returns True if the conclusion is a semantic consequence of the premises, false otherwise.\n   *\n   * @example\n   * const output = Calculator.isSemanticConsequence(['P->Q', 'P'], 'Q');\n   * console.log(output); // Output: true\n   */\n  static isSemanticConsequence(premises, conclusion) {\n    const variables = /* @__PURE__ */ new Set();\n    let conjunctionOfPremises;\n    if (typeof conclusion === \"string\" && !isPropositionalVariable(conclusion))\n      conclusion = parseToFormulaObject(conclusion);\n    if (premises.length === 1) {\n      conjunctionOfPremises = typeof premises[0] === \"object\" ? premises[0] : parseToFormulaObject(premises[0]);\n    } else {\n      if (!isArrayString(premises)) {\n        premises = premises.map((premise) => parseToFormulaString(premise));\n      }\n      let conjunctionFormulaString = buildConjunctionString(premises);\n      conjunctionOfPremises = parseToFormulaObject(conjunctionFormulaString);\n    }\n    _Calculator.collectVariables(conjunctionOfPremises, variables);\n    const variableArray = Array.from(variables);\n    const truthCombinations = _Calculator.generateTruthCombinations(variableArray.length);\n    for (const combination of truthCombinations) {\n      const values = {};\n      variableArray.forEach((variable, index) => {\n        values[variable] = !!combination[index];\n      });\n      const allPremisesAreTrue = _Calculator.evaluate(conjunctionOfPremises, values);\n      if (allPremisesAreTrue && !_Calculator.evaluate(conclusion, values))\n        return false;\n    }\n    return true;\n  }\n  static evaluateImplication(formula, values) {\n    const left = _Calculator.evaluate(formula.left, values);\n    const right = _Calculator.evaluate(formula.right, values);\n    return !left || right;\n  }\n  static evaluateBiconditional(formula, values) {\n    const left = _Calculator.evaluate(formula.left, values);\n    const right = _Calculator.evaluate(formula.right, values);\n    return left && right || !left && !right;\n  }\n  static evaluateConjunction(formula, values) {\n    const left = _Calculator.evaluate(formula.left, values);\n    const right = _Calculator.evaluate(formula.right, values);\n    return left && right;\n  }\n  static evaluateDisjunction(formula, values) {\n    const left = _Calculator.evaluate(formula.left, values);\n    const right = _Calculator.evaluate(formula.right, values);\n    return left || right;\n  }\n  static evaluateNegation(formula, values) {\n    const value = _Calculator.evaluate(formula.value, values);\n    return !value;\n  }\n  static generateTruthCombinations(numVariables) {\n    const combinations = [];\n    const totalCombinations = 2 ** numVariables;\n    for (let i = 0; i < totalCombinations; i++) {\n      const binaryString = i.toString(2).padStart(numVariables, \"0\");\n      const combination = binaryString.split(\"\").map((bit) => bit === \"1\");\n      combinations.push(combination);\n    }\n    return combinations;\n  }\n  static collectVariables(formula, variables) {\n    if (isPropositionalVariable(formula)) {\n      variables.add(formula);\n    } else if (isNegation(formula)) {\n      _Calculator.collectVariables(formula.value, variables);\n    } else {\n      _Calculator.collectVariables(formula.left, variables);\n      _Calculator.collectVariables(formula.right, variables);\n    }\n  }\n};\n\n// src/rulers/RuleApplier.ts\nimport { isDeepStrictEqual as isDeepStrictEqual3 } from \"util\";\n\n// src/rulers/RuleSetter.ts\nimport { isDeepStrictEqual as isDeepStrictEqual2 } from \"util\";\nvar RuleSetter = class {\n  static BiconditionalIntroduction(conditional1, conditional2) {\n    if (isDeepStrictEqual2(conditional1.left, conditional2.right) && isDeepStrictEqual2(conditional1.right, conditional2.left))\n      return {\n        operation: \"Biconditional\",\n        left: conditional1.left,\n        right: conditional1.right\n      };\n    const errorMsg = `Biconditional Introduction: cannot apply in ${parseToFormulaString(\n      conditional1\n    )} and ${parseToFormulaString(conditional2)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static BiconditionalElimination(biconditional2) {\n    const implication1 = {\n      operation: \"Implication\",\n      left: biconditional2.left,\n      right: biconditional2.right\n    };\n    const implication2 = {\n      operation: \"Implication\",\n      left: biconditional2.right,\n      right: biconditional2.left\n    };\n    return {\n      operation: \"Conjunction\",\n      left: implication1,\n      right: implication2\n    };\n  }\n  static ConditionalProof(hypothesis, conclusionOfHypothesis) {\n    const conditional = {\n      operation: \"Implication\",\n      left: hypothesis,\n      right: conclusionOfHypothesis\n    };\n    return conditional;\n  }\n  static Conditionalization(formula, conditional) {\n    if (isDeepStrictEqual2(formula, conditional.right))\n      return conditional;\n    throw new InferenceException(\n      `Conditionalization: cannot apply in ${parseToFormulaString(\n        conditional\n      )} with ${parseToFormulaString(formula)}`\n    );\n  }\n  static Commutativity(formula) {\n    const right = formula.right;\n    formula.right = formula.left;\n    formula.left = right;\n    return formula;\n  }\n  static Contraposition(formula) {\n    const contraposition = {\n      operation: \"Implication\",\n      left: { operation: \"Negation\", value: formula.right },\n      right: { operation: \"Negation\", value: formula.left }\n    };\n    return eliminateDoubleNegations(contraposition);\n  }\n  static ConjunctionIntroduction(formula1, formula2) {\n    return {\n      operation: \"Conjunction\",\n      left: formula1,\n      right: formula2\n    };\n  }\n  static ConjunctionElimination(conjunction2) {\n    return [conjunction2.left, conjunction2.right];\n  }\n  static DeMorgan(formula) {\n    if (isNegation(formula)) {\n      if (isDisjunction(formula.value)) {\n        return {\n          operation: \"Conjunction\",\n          left: { operation: \"Negation\", value: formula.value.left },\n          right: { operation: \"Negation\", value: formula.value.right }\n        };\n      }\n      if (isConjunction(formula.value)) {\n        return {\n          operation: \"Disjunction\",\n          left: { operation: \"Negation\", value: formula.value.left },\n          right: { operation: \"Negation\", value: formula.value.right }\n        };\n      }\n    }\n    if (isDisjunction(formula)) {\n      if (!(isNegation(formula.left) && isNegation(formula.right)))\n        throw new InferenceException(\n          `De Morgan: cannot apply in ${parseToFormulaString(formula)}`\n        );\n      return {\n        operation: \"Negation\",\n        value: {\n          operation: \"Conjunction\",\n          left: formula.left.value,\n          right: formula.right.value\n        }\n      };\n    }\n    if (isConjunction(formula)) {\n      if (!(isNegation(formula.left) && isNegation(formula.right)))\n        throw new InferenceException(\n          `De Morgan: cannot apply in ${parseToFormulaString(formula)}`\n        );\n      return {\n        operation: \"Negation\",\n        value: {\n          operation: \"Disjunction\",\n          left: formula.left.value,\n          right: formula.right.value\n        }\n      };\n    }\n    throw new InferenceException(\n      `De Morgan: cannot apply in ${parseToFormulaString(formula)}`\n    );\n  }\n  static DisjunctionIntroduction(formula, disjunction2) {\n    if (isDeepStrictEqual2(disjunction2.left, formula))\n      return disjunction2;\n    if (isDeepStrictEqual2(disjunction2.right, formula))\n      return disjunction2;\n    const errorMsg = `Disjunction Introduction: cannot apply in ${parseToFormulaString(\n      disjunction2\n    )} with ${parseToFormulaString(formula)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static DisjunctiveSyllogism(disjunction2, negatedDisjunct) {\n    if (isDeepStrictEqual2(disjunction2.left, negatedDisjunct.value))\n      return disjunction2.right;\n    if (isDeepStrictEqual2(disjunction2.right, negatedDisjunct.value))\n      return disjunction2.left;\n    const errorMsg = `Disjunctive Syllogism: cannot apply in ${parseToFormulaString(\n      disjunction2\n    )} with ${parseToFormulaString(negatedDisjunct)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static ImplicationElimination(conditional) {\n    return {\n      operation: \"Disjunction\",\n      left: { operation: \"Negation\", value: conditional.left },\n      right: conditional.right\n    };\n  }\n  static ImplicationNegation(negation2) {\n    if (!isImplication(negation2.value))\n      throw new InferenceException(\n        `Implication Negation: cannot apply in ${parseToFormulaString(\n          negation2\n        )}`\n      );\n    return {\n      operation: \"Conjunction\",\n      left: negation2.value.left,\n      right: { operation: \"Negation\", value: negation2.value.right }\n    };\n  }\n  static DoubleNegation(formula) {\n    return eliminateDoubleNegations(formula);\n  }\n  static DoubleNegationIntroduction(formula) {\n    const negation2 = {\n      operation: \"Negation\",\n      value: { operation: \"Negation\", value: formula }\n    };\n    return negation2;\n  }\n  static ConjunctionOverDisjunctionDistribution(formula) {\n    return this.Distribute(formula, isDisjunction);\n  }\n  static DisjunctionOverConjunctionDistribution(formula) {\n    return this.Distribute(formula, isConjunction);\n  }\n  static ConjunctionAssociativity(formula) {\n    return this.Associate(formula, isConjunction);\n  }\n  static DisjunctionAssociativity(formula) {\n    return this.Associate(formula, isDisjunction);\n  }\n  static BiconditionalAssociativity(formula) {\n    return this.Associate(formula, isBiconditional);\n  }\n  static HypotheticalSyllogism(conditional1, conditional2) {\n    if (isDeepStrictEqual2(conditional1.right, conditional2.left)) {\n      return {\n        operation: \"Implication\",\n        left: conditional1.left,\n        right: conditional2.right\n      };\n    }\n    if (isDeepStrictEqual2(conditional1.left, conditional2.right)) {\n      return {\n        operation: \"Implication\",\n        left: conditional2.left,\n        right: conditional1.right\n      };\n    }\n    const errorMsg = `Hypothetical Syllogism: cannot apply in ${parseToFormulaString(\n      conditional1\n    )} with ${parseToFormulaString(conditional2)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static ModusPonens(conditional, antecedent) {\n    if (isDeepStrictEqual2(conditional.left, antecedent))\n      return conditional.right;\n    const errorMsg = `Modus Ponens: cannot apply in ${parseToFormulaString(\n      conditional\n    )} with ${parseToFormulaString(antecedent)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static ModusTollens(conditional, negatedConsequent) {\n    if (isDeepStrictEqual2(conditional.right, negatedConsequent.value))\n      return { operation: \"Negation\", value: conditional.left };\n    const errorMsg = `Modus Tollens: cannot apply in ${parseToFormulaString(\n      conditional\n    )} with ${parseToFormulaString(negatedConsequent)}`;\n    throw new InferenceException(errorMsg);\n  }\n  static ReductioAdAbsurdum(conditional) {\n    if (isContradiction(conditional.right))\n      return { operation: \"Negation\", value: conditional.left };\n    throw new InferenceException(\n      `Reductio Ad Absurdum: cannot apply in ${conditional} with ${conditional.right}`\n    );\n  }\n  static DistributeRecursively(formula, isK) {\n    try {\n      return this.Distribute(formula, isK);\n    } catch (e) {\n      return formula;\n    }\n  }\n  static Distribute(formula, isK) {\n    let KFormula;\n    let otherFormula;\n    if (isK(formula.left)) {\n      KFormula = formula.left;\n      otherFormula = formula.right;\n    } else if (isK(formula.right)) {\n      KFormula = formula.right, otherFormula = formula.left;\n    } else {\n      throw new InferenceException(\n        `Distribution: cannot apply in ${parseToFormulaString(formula)}`\n      );\n    }\n    let distributedFormula = {\n      operation: KFormula.operation,\n      left: {\n        operation: formula.operation,\n        left: otherFormula,\n        right: KFormula.left\n      },\n      right: {\n        operation: formula.operation,\n        left: otherFormula,\n        right: KFormula.right\n      }\n    };\n    if (!isPropositionalVariable(distributedFormula.left))\n      distributedFormula.left = this.DistributeRecursively(\n        distributedFormula.left,\n        isK\n      );\n    if (!isPropositionalVariable(distributedFormula.right))\n      distributedFormula.right = this.DistributeRecursively(\n        distributedFormula.right,\n        isK\n      );\n    return distributedFormula;\n  }\n  static Associate(formula, isT) {\n    let mainFormula;\n    let otherFormula;\n    if (isT(formula.left)) {\n      mainFormula = formula.left;\n      otherFormula = formula.right;\n      return {\n        operation: formula.operation,\n        left: mainFormula.left,\n        right: {\n          operation: formula.operation,\n          left: mainFormula.right,\n          right: otherFormula\n        }\n      };\n    }\n    if (isT(formula.right)) {\n      mainFormula = formula.right;\n      otherFormula = formula.left;\n      return {\n        operation: formula.operation,\n        left: {\n          operation: formula.operation,\n          left: otherFormula,\n          right: mainFormula.left\n        },\n        right: mainFormula.right\n      };\n    }\n    throw new InferenceException(\n      `Associativity: cannot apply in ${parseToFormulaString(formula)}`\n    );\n  }\n};\n\n// src/rulers/RuleApplier.ts\nvar RuleApplier = class _RuleApplier extends RuleSetter {\n  static biconditionalIntroduction(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const formulas = [\n      proof[requiredItens[0]].expression,\n      proof[requiredItens[1]].expression\n    ];\n    if (!isImplication(formulas[0]) || !isImplication(formulas[1]))\n      throw new InferenceException(\n        `Biconditional Introduction (Line ${line}): conditionals not found.`\n      );\n    const inferenceResult = _RuleApplier.BiconditionalIntroduction(\n      formulas[0],\n      formulas[1]\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static biconditionalElimination(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const biconditional2 = proof[requiredItem[0]].expression;\n    if (!isBiconditional(biconditional2))\n      throw new InferenceException(\n        `Biconditional Elimination (Line ${line}): biconditional not found.`\n      );\n    const inferenceResult = _RuleApplier.BiconditionalElimination(biconditional2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conditionalization(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    if (!isImplication(item.expression))\n      throw new InferenceException(\n        `Conditionalization (Line ${line}): the formula is not an implication.`\n      );\n    const formula = proof[requiredItem[0]].expression;\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula))\n      throw new InferenceException(\n        `Conditionalization (Line ${line}): formula not found.`\n      );\n    const inferenceResult = _RuleApplier.Conditionalization(\n      formula,\n      item.expression\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conjunctionIntroduction(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const firstFormula = proof[requiredItens[0]].expression;\n    if (typeof firstFormula === \"string\" && !isPropositionalVariable(firstFormula))\n      throw new InferenceException(\n        `Conjunction Introduction (Line ${line}): line ${requiredItens[0]} formula not found.`\n      );\n    const secondFormula = proof[requiredItens[1]].expression;\n    if (typeof secondFormula === \"string\" && !isPropositionalVariable(secondFormula))\n      throw new InferenceException(\n        `Conjunction Introduction (Line ${line}): line ${requiredItens[1]} formula not found.`\n      );\n    const inferenceResult = _RuleApplier.ConjunctionIntroduction(\n      firstFormula,\n      secondFormula\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conjunctionElimination(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const conjunction2 = proof[requiredItem[0]].expression;\n    if (!isConjunction(conjunction2))\n      throw new InferenceException(\n        `Conjunction Elimination (Line ${line}): conjunction not found.`\n      );\n    const inferenceResults = _RuleApplier.ConjunctionElimination(conjunction2);\n    if (!isDeepStrictEqual3(item.expression, inferenceResults[0]) && !isDeepStrictEqual3(item.expression, inferenceResults[1])) {\n      throw new InferenceException(\n        `Conjunction Elimination (Line ${line}): expected ${parseToFormulaString(\n          inferenceResults[0]\n        )} or ${parseToFormulaString(\n          inferenceResults[1]\n        )} but received ${parseToFormulaString(item.expression)}`\n      );\n    }\n    return inferenceResults;\n  }\n  static commutativity(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (!isDisjunction(formula) && !isConjunction(formula) && !isBiconditional(formula))\n      throw new InferenceException(\n        `Commutativity (Line ${line}): cannot find any conjunction, biconditional or disjunction.`\n      );\n    const inferenceResult = _RuleApplier.Commutativity(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static contraposition(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (!isImplication(formula))\n      throw new InferenceException(\n        `Contraposition (Line ${line}): implication not found.`\n      );\n    const inferenceResult = _RuleApplier.Contraposition(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static deMorgan(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (!isNegation(formula) && !isConjunction(formula) && !isDisjunction(formula))\n      throw new InferenceException(\n        `De Morgan (Line ${line}): formula is not a disjunction, conjunction or negation.`\n      );\n    const inferenceResult = _RuleApplier.DeMorgan(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static disjunctionIntroduction(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    if (!isDisjunction(item.expression))\n      throw new InferenceException(\n        `Disjunction Introduction (Line ${line}): expression is not a disjunction`\n      );\n    const formula = proof[requiredItem[0]].expression;\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula))\n      throw new InferenceException(\n        `Disjunction Introduction (Line ${line}): formula not found.`\n      );\n    const inferenceResult = _RuleApplier.DisjunctionIntroduction(\n      formula,\n      item.expression\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static disjunctiveSyllogism(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const firstFormula = proof[requiredItens[0]].expression;\n    const secondFormula = proof[requiredItens[1]].expression;\n    let remainingFormula;\n    let disjunction2;\n    if (isDisjunction(firstFormula)) {\n      disjunction2 = firstFormula;\n      remainingFormula = secondFormula;\n    }\n    if (isDisjunction(secondFormula)) {\n      disjunction2 = secondFormula;\n      remainingFormula = firstFormula;\n    }\n    if (!disjunction2)\n      throw new InferenceException(\n        `Disjunctive Syllogism (Line ${line}): disjunction not found`\n      );\n    let negation2;\n    if (isNegation(remainingFormula))\n      negation2 = remainingFormula;\n    if (!negation2)\n      throw new InferenceException(\n        `Disjunctive Syllogism (Line ${line}): negation not found`\n      );\n    const inferenceResult = _RuleApplier.DisjunctiveSyllogism(\n      disjunction2,\n      negation2\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static doubleNegation(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula))\n      throw new InferenceException(\n        `Double Negation (Line ${line}): formula not found.`\n      );\n    const inferenceResult = _RuleApplier.DoubleNegation(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static doubleNegationIntroduction(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (typeof formula === \"string\" && !isPropositionalVariable(formula))\n      throw new InferenceException(\n        `Double Negation Introduction (Line ${line}): negation not found.`\n      );\n    const inferenceResult = _RuleApplier.DoubleNegationIntroduction(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static hypotheticalSyllogism(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const firstFormula = proof[requiredItens[0]].expression;\n    const secondFormula = proof[requiredItens[1]].expression;\n    if (!isImplication(firstFormula) || !isImplication(secondFormula))\n      throw new InferenceException(\n        `Hypothetical Syllogism (Line ${line}): both formulas should be conditionals.`\n      );\n    const inferenceResult = _RuleApplier.HypotheticalSyllogism(\n      firstFormula,\n      secondFormula\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static implicationElimination(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const formula = proof[requiredItem[0]].expression;\n    if (!isImplication(formula))\n      throw new InferenceException(\n        `Implication Elimination (Line ${line}): implication not found.`\n      );\n    const inferenceResult = _RuleApplier.ImplicationElimination(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static implicationNegation(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    let formula = proof[requiredItem[0]].expression;\n    if (!isNegation(formula))\n      throw new InferenceException(\n        `Implication Negation (Line ${line}): negation not found`\n      );\n    const inferenceResult = _RuleApplier.ImplicationNegation(formula);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static modusPonens(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    let firstFormula = proof[requiredItens[0]].expression;\n    let secondFormula = proof[requiredItens[1]].expression;\n    let remainingFormula;\n    let implication2;\n    if (isImplication(firstFormula)) {\n      implication2 = firstFormula;\n      remainingFormula = secondFormula;\n    }\n    if (isImplication(secondFormula)) {\n      implication2 = secondFormula;\n      remainingFormula = firstFormula;\n    }\n    if (!implication2)\n      throw new InferenceException(\n        `Modus Ponens (Line ${line}): implication not found`\n      );\n    const antecedent = remainingFormula;\n    if (!isPropositionalVariable(antecedent) && typeof antecedent === \"string\")\n      throw new InferenceException(\n        `Modus Ponens (Line ${line}): antecedent not found`\n      );\n    const inferenceResult = _RuleApplier.ModusPonens(implication2, antecedent);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static modusTollens(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const firstFormula = proof[requiredItens[0]].expression;\n    const secondFormula = proof[requiredItens[1]].expression;\n    let remainingFormula;\n    let implication2;\n    if (isImplication(firstFormula)) {\n      implication2 = firstFormula;\n      remainingFormula = secondFormula;\n    }\n    if (isImplication(secondFormula)) {\n      implication2 = secondFormula;\n      remainingFormula = firstFormula;\n    }\n    if (!implication2)\n      throw new InferenceException(\n        `Modus Tollens (Line ${line}): implication not found`\n      );\n    const consequent = remainingFormula;\n    if (!isNegation(consequent))\n      throw new InferenceException(\n        `Modus Tollens (Line ${line}): negated consequent not found`\n      );\n    const inferenceResult = _RuleApplier.ModusTollens(implication2, consequent);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conjunctionOverDisjunctionDistribution(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const conjunction2 = proof[requiredItem[0]].expression;\n    if (!isConjunction(conjunction2))\n      throw new InferenceException(\n        `Distribution (Line ${line}): conjunction not found.`\n      );\n    const inferenceResult = _RuleApplier.ConjunctionOverDisjunctionDistribution(conjunction2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static disjunctionOverConjunctionDistribution(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const disjunction2 = proof[requiredItem[0]].expression;\n    if (!isDisjunction(disjunction2))\n      throw new InferenceException(\n        `Distribution (Line ${line}): disjunction not found.`\n      );\n    const inferenceResult = _RuleApplier.DisjunctionOverConjunctionDistribution(disjunction2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conjunctionAssociativity(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const conjunction2 = proof[requiredItem[0]].expression;\n    if (!isConjunction(conjunction2))\n      throw new InferenceException(\n        `Associativity (Line ${line}): conjunction not found.`\n      );\n    const inferenceResult = _RuleApplier.ConjunctionAssociativity(conjunction2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static disjunctionAssociativity(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const disjunction2 = proof[requiredItem[0]].expression;\n    if (!isDisjunction(disjunction2))\n      throw new InferenceException(\n        `Associativity (Line ${line}): disjunction not found.`\n      );\n    const inferenceResult = _RuleApplier.DisjunctionAssociativity(disjunction2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static biconditionalAssociativity(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const biconditional2 = proof[requiredItem[0]].expression;\n    if (!isBiconditional(biconditional2))\n      throw new InferenceException(\n        `Associativity (Line ${line}): disjunction not found.`\n      );\n    const inferenceResult = _RuleApplier.BiconditionalAssociativity(biconditional2);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static conditionalProof(item, proof) {\n    const requiredItens = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 2, requiredItens.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItens, proof);\n    const item1 = proof[requiredItens[0]];\n    const item2 = proof[requiredItens[1]];\n    if (!isPropositionalVariable(item2.expression) && typeof item2.expression === \"string\")\n      throw new InferenceException(\n        `Conditional Proof (Line ${line}): cannot find a formula at line ${item2.id}`\n      );\n    if (!isPropositionalVariable(item1.expression) && typeof item1.expression === \"string\")\n      throw new InferenceException(\n        `Conditional Proof (Line ${line}): cannot find a formula at line ${item1.id}`\n      );\n    let hypothesis;\n    let endOfHypothesis;\n    if (isHypothesis(item1) && isEndOfHypothesis(item2)) {\n      hypothesis = item1.expression;\n      if (item2.hypothesisId != item1.id)\n        throw new InferenceException(\n          `Conditional Proof (Line ${line}): end of hypothesis references line ${item2.hypothesisId} hypothesis, but received line ${item1.id} hypothesis`\n        );\n      endOfHypothesis = item2.expression;\n    } else if (isHypothesis(item2) && isEndOfHypothesis(item1)) {\n      hypothesis = item2.expression;\n      if (item1.hypothesisId != item2.id)\n        throw new InferenceException(\n          `Conditional Proof (Line ${line}): end of hypothesis references line ${item1.hypothesisId} hypothesis, but received line ${item2.id} hypothesis`\n        );\n      endOfHypothesis = item1.expression;\n    } else {\n      throw new InferenceException(\n        `Conditional Proof: end of hypothesis or hypothesis not found.`\n      );\n    }\n    const inferenceResult = _RuleApplier.ConditionalProof(\n      hypothesis,\n      endOfHypothesis\n    );\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static reductioAdAbsurdum(item, proof) {\n    const requiredItem = item.from[0];\n    const line = item.id;\n    _RuleApplier.throwsIfLengthDoesntMatch(item, 1, requiredItem.length);\n    _RuleApplier.throwsIfIndexDoesntExist(requiredItem, proof);\n    const conditional = proof[requiredItem[0]].expression;\n    if (!isImplication(conditional))\n      throw new InferenceException(\n        `Reductio Ad Absurdum (Line ${line}): conditional not found.`\n      );\n    const inferenceResult = _RuleApplier.ReductioAdAbsurdum(conditional);\n    _RuleApplier.throwsIfIsNotEqual(inferenceResult, item);\n    return inferenceResult;\n  }\n  static throwsIfIsNotEqual(expectedFormula, actualItem) {\n    const actualFormula = actualItem.expression;\n    const inferenceMethod = actualItem.from[1];\n    if (!isDeepStrictEqual3(expectedFormula, actualFormula)) {\n      throw new InferenceException(`\n        ${inferenceMethod} (Line ${actualItem.id}): expected ${parseToFormulaString(\n        expectedFormula\n      )} but received ${parseToFormulaString(actualFormula)}\n      `);\n    }\n  }\n  static throwsIfLengthDoesntMatch(item, expected, received) {\n    const rule = item.from[1];\n    const line = item.id;\n    if (expected !== received)\n      throw new InferenceException(\n        `${rule} (Line ${line}): expect ${expected} formulas to apply the rule but received ${received}.`\n      );\n  }\n  static throwsIfIndexDoesntExist(requiredItens, proof) {\n    requiredItens.forEach((idx) => {\n      if (!proof[idx])\n        throw new InferenceException(`Cannot find a formula at index ${idx}`);\n    });\n  }\n};\n\n// src/types/syntactic/proof.ts\nvar inferenceRulesMap = {\n  \"Associativity (Biconditional)\": RuleApplier.biconditionalAssociativity,\n  \"Associativity (Conjunction)\": RuleApplier.conjunctionAssociativity,\n  \"Associativity (Disjunction)\": RuleApplier.disjunctionAssociativity,\n  \"Biconditional Elimination\": RuleApplier.biconditionalElimination,\n  \"Biconditional Introduction\": RuleApplier.biconditionalIntroduction,\n  \"Commutativity\": RuleApplier.commutativity,\n  \"Conditional Proof\": RuleApplier.conditionalProof,\n  \"Conditionalization\": RuleApplier.conditionalization,\n  \"Contraposition\": RuleApplier.contraposition,\n  \"Conjunction Elimination\": RuleApplier.conjunctionElimination,\n  \"Conjunction Introduction\": RuleApplier.conjunctionIntroduction,\n  \"De Morgan\": RuleApplier.deMorgan,\n  \"Disjunction Introduction\": RuleApplier.disjunctionIntroduction,\n  \"Disjunctive Syllogism\": RuleApplier.disjunctiveSyllogism,\n  \"Distribution (Conjunction over Disjunction)\": RuleApplier.conjunctionOverDisjunctionDistribution,\n  \"Distribution (Disjunction over Conjunction)\": RuleApplier.disjunctionOverConjunctionDistribution,\n  \"Double Negation\": RuleApplier.doubleNegation,\n  \"Double Negation Introduction\": RuleApplier.doubleNegationIntroduction,\n  \"Hypothetical Syllogism\": RuleApplier.hypotheticalSyllogism,\n  \"Implication Elimination\": RuleApplier.implicationElimination,\n  \"Implication Negation\": RuleApplier.implicationNegation,\n  \"Modus Ponens\": RuleApplier.modusPonens,\n  \"Modus Tollens\": RuleApplier.modusTollens,\n  \"Reductio Ad Absurdum\": RuleApplier.reductioAdAbsurdum\n};\n\n// src/proof-checker/ProofChecker.ts\nvar ProofChecker = class _ProofChecker {\n  /**\n   * Checks the given proof for validity.\n   *\n   * @param {Proof} proof - The proof to be checked.\n   * @returns {boolean} - `true` if the proof is valid, `InferenceError` or `Error` otherwise.\n   */\n  static check(proof) {\n    const mappedProof = _ProofChecker.createMappedProof(proof);\n    let premises = [];\n    let conclusion;\n    Object.keys(mappedProof).forEach((_, idx) => {\n      const item = mappedProof[idx + 1];\n      if (isProofItemInferred(item)) {\n        const [requiredItens, inferenceRule] = item.from;\n        _ProofChecker.validateScope(requiredItens, item, mappedProof);\n        inferenceRulesMap[inferenceRule](item, proof);\n        console.log(\n          \"\\x1B[32m\",\n          `Applied ${inferenceRule} with success at line ${item.id} \\u2714\\uFE0F`\n        );\n      }\n      if (item.type === \"Premise\") {\n        premises.push(item.expression);\n      }\n      if (item.type === \"Conclusion\") {\n        conclusion = parseToFormulaString(item.expression);\n      }\n      premises = premises.map((formula) => {\n        return parseToFormulaString(formula);\n      });\n    });\n    console.log(\"\\x1B[0m\", `\n{ ${premises.join(\", \")} } \\u22A2 ${conclusion}`);\n    return true;\n  }\n  /**\n   * Creates a mapped version of the proof, with the representation of the scopes of each item.\n   * @param {Proof} proof - The proof to be mapped.\n   * @returns {MappedProof} - The mapped proof.\n   */\n  static createMappedProof(proof) {\n    let layerIdx = 0;\n    let blockIdx = 0;\n    Object.keys(proof).forEach((_, idx) => {\n      idx++;\n      const item = proof[idx];\n      if (isHypothesis(item)) {\n        blockIdx++;\n        layerIdx++;\n        proof[idx][\"scopeIdx\"] = [layerIdx, blockIdx];\n      } else if (isEndOfHypothesis(item)) {\n        const itemBlockIdx = proof[item.hypothesisId][\"scopeIdx\"][1];\n        proof[idx][\"scopeIdx\"] = [layerIdx, itemBlockIdx];\n        layerIdx--;\n      } else {\n        proof[idx][\"scopeIdx\"] = layerIdx === 0 ? [0, 0] : [layerIdx, blockIdx];\n        if (layerIdx !== 0 && proof[idx].type === \"Conclusion\")\n          throw new Error(\n            `(Line ${idx}): You cannot put your conclusion inside of a hypothesis.`\n          );\n      }\n    });\n    return proof;\n  }\n  /**\n   * Validates the scope of inferred items.\n   * @param {number[]} requiredItens - An array of required item IDs.\n   * @param {ProofItemInferred} item - The inferred proof item to be validated.\n   * @param {MappedProof} mappedProof - The mapped proof.\n   */\n  static validateScope(requiredItens, item, mappedProof) {\n    requiredItens.forEach((requiredItemId) => {\n      const [actualLayer, actualBlock] = mappedProof[item.id].scopeIdx;\n      const [requiredLayer, requiredBlock] = mappedProof[requiredItemId].scopeIdx;\n      const [, inferenceRule] = item.from;\n      if (actualLayer < requiredLayer && actualBlock != requiredBlock && inferenceRule != \"Conditional Proof\")\n        throw new InferenceException(\n          `Scope Error: cannot access line ${requiredItemId} by the ${item.id} line.`\n        );\n    });\n  }\n};\n\n// src/reducer/Reducer.ts\nvar Reducer = class {\n  /**\n   * Recursively reduces a logical formula to its reduced form based on its operation.\n   * @param x - The logical formula to reduce.\n   * @returns The reduced logical formula.\n   */\n  static reduceFormula(x) {\n    if (typeof x === \"string\")\n      return x;\n    switch (x.operation) {\n      case \"Biconditional\":\n        return this.biconditional(x);\n      case \"Implication\":\n        return this.implication(x);\n      case \"Conjunction\":\n        return this.conjunction(x);\n      case \"Disjunction\":\n        return this.disjunction(x);\n      case \"Negation\":\n        return this.negation(x);\n      default:\n        throw new Error(\"Invalid operation\");\n    }\n  }\n  /**\n   * Reduces a Biconditional to a Conjunction.\n   * @param x - The Biconditional operation to reduce.\n   * @returns The reduced Conjunction formula.\n   */\n  static biconditional(x) {\n    const left = this.reduceFormula(x.left);\n    const right = this.reduceFormula(x.right);\n    const reducedLeft = this.reduceFormula({\n      operation: \"Implication\",\n      left,\n      right\n    });\n    const reducedRight = this.reduceFormula({\n      operation: \"Implication\",\n      left: right,\n      right: left\n    });\n    return {\n      operation: \"Conjunction\",\n      left: reducedLeft,\n      right: reducedRight\n    };\n  }\n  /**\n   * Reduces an Implication to a Disjunction\n   * @param x - The formula to reduce.\n   * @returns The reduced Disjunction formula.\n   */\n  static implication(x) {\n    const left = this.reduceFormula(x.left);\n    const right = this.reduceFormula(x.right);\n    return {\n      operation: \"Disjunction\",\n      left: {\n        operation: \"Negation\",\n        value: left\n      },\n      right\n    };\n  }\n  /**\n   * Reduces both sides of a Conjunction\n   * @param x - The formula to reduce.\n   * @returns The reduced Conjunction formula.\n   */\n  static conjunction(x) {\n    const left = this.reduceFormula(x.left);\n    const right = this.reduceFormula(x.right);\n    return {\n      operation: \"Conjunction\",\n      left,\n      right\n    };\n  }\n  /**\n   * Reduces both sides of a Disjunction\n   * @param x - The formula to reduce.\n   * @returns The reduced Disjunction formula.\n   */\n  static disjunction(x) {\n    const left = this.reduceFormula(x.left);\n    const right = this.reduceFormula(x.right);\n    return {\n      operation: \"Disjunction\",\n      left,\n      right\n    };\n  }\n  /**\n   * Reduces the negated formula\n   * @param x - The formula to reduce.\n   * @returns The reduced Negation formula.\n   */\n  static negation(x) {\n    const value = this.reduceFormula(x.value);\n    return {\n      operation: \"Negation\",\n      value\n    };\n  }\n};\n\n// src/frege/Frege.ts\nvar Frege = class {\n  constructor() {\n    this.builder = Builder;\n    this.reducer = Reducer;\n    this.calculator = Calculator;\n    this.proofChecker = ProofChecker;\n    /**\n     * The `parse` property provides functions to build and parse formulas in propositional logic.\n     * @public\n     */\n    this.parse = {\n      /**\n       * Builds a formula object from a string, which contains a well-formed formula of the propositional logic.\n       * @param formula - The logical formula to build.\n       * @returns The built formula object.\n       * @throws {UnrecognizedTokenException} If the provided formula contains unrecognized tokens.\n       *\n       * @example\n       *\n       * // Input: \"P->Q\"\n       * // Output: { operation: 'Implication', left: 'P', right: 'Q' }\n       * const parsedFormula = frege.parse.toFormulaObject<Implication>(\"P->Q\");\n       * console.log(parsedFormula);\n       */\n      toFormulaObject: (formula) => {\n        const tokens = new Lexer(formula).lex();\n        const parsedFormula = new Parser(tokens).parse();\n        return parsedFormula;\n      },\n      /**\n       * Builds a logical formula string from a formula object using the syntax of propositional logic.\n       * @param formula - The formula object to build the string from.\n       * @returns The built logical formula string.\n       * @throws {InvalidFormulaException} If the provided formula object is invalid or incomplete.\n       *\n       * @example\n       *\n       * // Input: { operation: 'Implication', left: 'P', right: 'Q' }\n       * // Output: \"(P->Q)\"\n       * const implication: Implication = {\n       *    operation: 'Implication',\n       *    left: 'P',\n       *    right: 'Q'\n       * };\n       *\n       * const parsedFormula = frege.parse.toFormulaString(implication);\n       * console.log(parsedFormula); // => \"(P->Q)\"\n       */\n      toFormulaString: (formula) => {\n        return this.builder.buildFormula(formula);\n      }\n    };\n    this.verifyConsequence = {\n      semantic: this.calculator.isSemanticConsequence,\n      syntactic: () => {\n      }\n    };\n    /**\n     * Reduces a formula object or a formula string to its reduced form.\n     * @param formula - The formula object or formula string to reduce.\n     * @returns The reduced formula in its string representation or as a formula object.\n     *\n     * @example\n     * // Input: { operation: 'Implication', left: 'P', right: ' Q' }\n     * // Output: { operation: 'Disjunction' left: { operation: 'Negation', value: 'P'}, right: 'Q' };\n     *\n     * const formulaObject: Implication = {\n     *    operation: 'Implication',\n     *    left: 'P',\n     *    right: 'Q'\n     * };\n     *\n     * const reducedFormula = frege.reduce(formulaObject);\n     * console.log(reducedFormula); // => { operation: 'Disjunction' left: { operation: 'Negation', value: 'P'}, right: 'Q' };\n     *\n     *\n     * // Input: \"P<->Q\"\n     * // Output: '((¬(P) ∨ Q) ∧ (¬(Q) ∨ P))'\n     *\n     * const formulaString = \"P<->Q\";\n     *\n     * const reducedFormula = frege.reduce(formulaString);\n     * console.log(reducedFormula); // => '((¬(P) ∨ Q) ∧ (¬(Q) ∨ P))'\n     */\n    this.reduce = (formula) => {\n      if (typeof formula === \"string\") {\n        let formulaObject = this.parse.toFormulaObject(formula);\n        formulaObject = this.reducer[\"reduceFormula\"](formulaObject);\n        return this.parse.toFormulaString(formulaObject);\n      }\n      let operation = formula.operation.toLocaleLowerCase();\n      const reducedFormula = this.reducer[operation](formula);\n      return reducedFormula;\n    };\n    /**\n     * Evaluates the given logical formula with the provided truth values for variables.\n     *\n     * @param formula - The logical formula to evaluate.\n     * @param values - An object representing truth values for propositional variables.\n     * @returns The result of the evaluation (true or false).\n     *\n     * @example\n     * const result = Calculator.evaluate('P -> Q', { P: true, Q: false });\n     * console.log(result); // Output: false\n     */\n    this.evaluate = this.calculator.evaluate;\n    /**\n     * Generates a truth table for the given formula.\n     *\n     * @param formula - The logical formula to generate a truth table for.\n     * @param stringfiedFormula - An optional string representation of the formula.\n     * @returns The truth table as an array containing headers, truth combinations, and results.\n     *\n     * @example\n     * const output = Calculator.generateTruthTable('P -> Q');\n     * console.log(output);\n     * // Output:\n     * {\n     *    headers: ['P', 'Q', '(P -> Q)'],\n     *    truthCombinations: [\n     *      [false, false], [false, true],\n     *      [true, false], [true, true]\n     *    ],\n     *    truthValues: [true, true, false, true]\n     *  }\n     */\n    this.generateTruthTable = this.calculator.generateTruthTable;\n    /**\n       * Checks the given proof for validity.\n       * \n       * @param {Proof} proof - The proof to be checked.\n       * @returns {boolean} - `true` if the proof is valid, `InferenceError` or `Error` otherwise.\n       * @example\n       * ```\n       * const proof = {\n        // ... (Your proof object)\n        };\n    \n        const isProofValid = ProofChecker.check(proof);\n        console.log(`The proof is valid: ${isProofValid}`);\n       * ```\n       */\n    this.checkProof = this.proofChecker.check;\n    /**\n     * Checks if the given formula is a tautology.\n     *\n     * @param {Formula | string} formula - The formula to check.\n     */\n    this.isTautology = (formula) => {\n      const { truthValues } = this.calculator.generateTruthTable(formula);\n      for (let i = 0; i < truthValues.length; i++) {\n        if (!truthValues[i])\n          return false;\n      }\n      return true;\n    };\n    /**\n     * Checks if the given formula is a contradiction.\n     *\n     * @param {Formula | string} formula - The formula to check.\n     */\n    this.isContradiction = (formula) => {\n      const { truthValues } = this.calculator.generateTruthTable(formula);\n      for (let i = 0; i < truthValues.length; i++) {\n        if (truthValues[i])\n          return false;\n      }\n      return true;\n    };\n    /**\n     * Checks if the given formula is a contingency.\n     *\n     * @param {Formula | string} formula - The formula to check.\n     */\n    this.isContingency = (formula) => {\n      let firstTruthValue;\n      const { truthValues } = this.calculator.generateTruthTable(formula);\n      firstTruthValue = truthValues[0];\n      for (let i = 1; i < truthValues.length; i++) {\n        if (truthValues[i] != firstTruthValue)\n          return true;\n      }\n      return false;\n    };\n  }\n};\n\n// src/index.ts\nvar frege = new Frege();\nexport {\n  Builder,\n  Calculator,\n  Frege,\n  InferenceException,\n  InvalidFormulaException,\n  InvalidProofSequenceException,\n  Lexer,\n  Parser,\n  ProofChecker,\n  Reducer,\n  RuleApplier,\n  RuleSetter,\n  UnrecognizedTokenException,\n  biconditional,\n  buildConjunctionString,\n  conjunction,\n  disjunction,\n  eliminateDoubleNegations,\n  frege,\n  haveEvenNumberOfNegations,\n  implication,\n  inferenceRulesMap,\n  isArrayString,\n  isBiconditional,\n  isBinaryOperationFormula,\n  isConjunction,\n  isContradiction,\n  isDisjunction,\n  isEndOfHypothesis,\n  isHypothesis,\n  isImplication,\n  isMolecularFormula,\n  isNegation,\n  isProofItemInferred,\n  isPropositionalVariable,\n  negation,\n  parseToFormulaObject,\n  parseToFormulaString,\n  printTruthTable\n};\n","import { frege } from 'fregejs';\r\n\r\n\r\ndocument.querySelectorAll(\".logic-button\").forEach((button) => {\r\n  button.addEventListener(\"click\", function () {\r\n    insert(this.textContent);\r\n  });\r\n});\r\ndocument.querySelectorAll(\".button\").forEach((button) => {\r\n  button.addEventListener(\"click\", function () {\r\n      if (this.textContent === \"DEL\") {\r\n          var telinha = document.getElementById(\"resultado\");\r\n          telinha.textContent = telinha.textContent.slice(0, -1); \r\n      } else if (this.textContent === \"AC\") {\r\n          var telinha = document.getElementById(\"resultado\");\r\n          telinha.textContent = \"\";\r\n      }\r\n  });\r\n});\r\n\r\ndocument.addEventListener(\"keydown\", function (event) {\r\n  if (event.key === \"Backspace\") {\r\n    deleteChar();\r\n  } else if (event.key === \"ArrowLeft\") {\r\n    moveCursorLeft();\r\n  } else if (event.key === \"ArrowRight\") {\r\n    moveCursorRight();\r\n  }\r\n  else\r\n    event.preventDefault();\r\n});\r\n\r\nfunction insert(text) {\r\n  var telinha = document.getElementById(\"resultado\");\r\n  telinha.textContent += text;\r\n}\r\n\r\nfunction analiseLexica(formula) {\r\n  const regex = /^[~^v→↔]+$/;\r\n  return regex.test(formula);\r\n}\r\n\r\nfunction analisadorSintatico(formula) {\r\n  try {\r\n    new Function(\"return \" + formula); \r\n    return true; \r\n  } catch (error) {\r\n    return false; \r\n  }\r\n}\r\n\r\n\r\nfunction exibirResultados(formula, tautologia) {\r\n  const resultsDiv = document.getElementById(\"results\");\r\n  resultsDiv.innerHTML = `\r\n    <p>Fórmula: ${formula}</p>\r\n    <p>Provador de Tautologia: ${\r\n      tautologia ? \"É uma tautologia\" : \"Não é uma tautologia\"\r\n    }</p>\r\n\r\n  `;\r\n}\r\nfunction exibirErro(formula) {\r\n  const resultsDiv = document.getElementById(\"results\");\r\n  resultsDiv.innerHTML = `\r\n    <p>Sua fórmula está incorreta: ${formula}</p>\r\n  `;\r\n}\r\n\r\n\r\ndocument.querySelector(\".button-calc\").addEventListener(\"click\", function() {\r\n  var expressaoLogica = document.getElementById(\"resultado\").textContent;\r\n  var resultadoCalculo = calcularExpressaoLogica(expressaoLogica);\r\n});\r\n\r\nfunction calcularExpressaoLogica(expressao) {\r\n    var expressaoNaoTratada = expressao\r\n    expressao = expressao.replace(/~/g, \"¬\");\r\n\r\n    expressao = expressao.replace(/→/g, \"->\");\r\n    expressao = expressao.replace(/↔/g, \"<->\");\r\n\r\n    try{\r\n      const truthTable = frege.generateTruthTable(expressao);\r\n      generateHTMLTruthTable(truthTable)\r\n      const tautologia = frege.isTautology(expressao);\r\n      exibirResultados(expressaoNaoTratada, tautologia);\r\n    } catch(error){\r\n      console.log(error)\r\n      exibirErro(expressaoNaoTratada)\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction generateHTMLTruthTable(truthTable) {\r\n  let htmlTable = '<table class=\"tabela-verdade\">';\r\n  \r\n  htmlTable += '<tr>';\r\n  truthTable.headers.forEach(header => {\r\n    htmlTable += `<th>${header}</th>`;\r\n  });\r\n  htmlTable += '</tr>';\r\n  \r\n  for (let i = 0; i < truthTable.truthCombinations.length; i++) {\r\n    htmlTable += '<tr>';\r\n    const combination = truthTable.truthCombinations[i];\r\n    combination.forEach(value => {\r\n      const formattedValue = value ? \"<span style='color:green'>T</span>\" : \"<span style='color:red'>F</span>\";\r\n      htmlTable += `<td class=\"tabela-verdade\">${formattedValue}</td>`;\r\n    });\r\n    const formattedValue = truthTable.truthValues[i] ? \"<span style='color:green'>T</span>\" : \"<span style='color:red'>F</span>\";\r\n    htmlTable += `<td class=\"tabela-verdade\">${formattedValue}</td>`;\r\n    htmlTable += '</tr>';\r\n  }\r\n\r\n  htmlTable += '</table>';\r\n  \r\n  var resultsDiv = document.getElementById(\"tabela\");\r\n  resultsDiv.innerHTML = htmlTable;\r\n}\r\n"]}